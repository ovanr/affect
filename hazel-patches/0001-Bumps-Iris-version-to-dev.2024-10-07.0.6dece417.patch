From 545f95fec93852c2fa82422251a31c7df39b1ddf Mon Sep 17 00:00:00 2001
From: Orpheas van Rooij <orpheas.vanrooij@outlook.com>
Date: Tue, 15 Oct 2024 17:15:24 +0100
Subject: [PATCH] Bumps Iris version to dev.2024-10-07.0.6dece417 - Adds a
 Hazel qualifier - Use Loc.fresh instead of fresh_locs - :> in classes no
 longer represent instances, replaced with :: - replace mapsto with pointsto -
 Update automatic_differentiation case study to use generalised gmap_viewR -
 other minor changes to tactics and lemmas used

---
 .gitignore                                    |  3 +
 _CoqProject                                   | 14 ++---
 opam                                          |  4 +-
 .../case_studies/asynchronous_computation.v   | 16 +++---
 .../case_studies/automatic_differentiation.v  | 57 +++++++++++--------
 theories/case_studies/callcc.v                | 12 ++--
 theories/case_studies/control_inversion.v     |  8 +--
 theories/case_studies/exceptions.v            |  2 +-
 theories/case_studies/iteration.v             | 12 ++--
 theories/case_studies/list_lib.v              |  2 +-
 theories/case_studies/map_lib.v               |  2 +-
 theories/case_studies/ml_references.v         |  0
 theories/case_studies/queue_lib.v             |  6 +-
 theories/case_studies/sat.v                   | 46 +++++++--------
 theories/case_studies/shallow_as_deep.v       |  2 +-
 theories/case_studies/shift_reset.v           |  6 +-
 theories/case_studies/state.v                 |  2 +-
 theories/language/eff_lang.v                  |  6 +-
 theories/language/iris_language.v             |  2 +-
 theories/language/neutral_contexts.v          |  2 +-
 theories/language/notation.v                  |  2 +-
 theories/language/properties.v                |  4 +-
 theories/language/semantics.v                 | 14 ++---
 theories/language/syntax.v                    |  4 +-
 theories/program_logic/adequacy.v             |  4 +-
 .../program_logic/basic_reasoning_rules.v     |  6 +-
 .../program_logic/deep_handler_reasoning.v    |  8 +--
 theories/program_logic/protocols.v            | 24 ++++----
 theories/program_logic/reasoning_rules.v      |  8 +--
 .../program_logic/shallow_handler_reasoning.v |  8 +--
 theories/program_logic/state_reasoning.v      | 24 ++++----
 theories/program_logic/tactics.v              |  4 +-
 theories/program_logic/weakest_precondition.v |  4 +-
 theories/program_logic_ext/named_effects.v    |  0
 34 files changed, 162 insertions(+), 156 deletions(-)
 delete mode 100644 theories/case_studies/ml_references.v
 delete mode 100644 theories/program_logic_ext/named_effects.v

diff --git a/.gitignore b/.gitignore
index df00fd7..bacf978 100644
--- a/.gitignore
+++ b/.gitignore
@@ -13,3 +13,6 @@ _opam
 build-dep
 .coq-native/
 _build
+Makefile.coq
+Makefile.coq.conf
+.Makefile.coq.d
diff --git a/_CoqProject b/_CoqProject
index 45b4b8f..862d450 100644
--- a/_CoqProject
+++ b/_CoqProject
@@ -1,10 +1,9 @@
--Q theories/lib               lib
--Q theories/language          language
--Q theories/program_logic     program_logic
--Q theories/program_logic_ext program_logic_ext
--Q theories/case_studies      case_studies
+-Q theories/lib               hazel.lib
+-Q theories/language          hazel.language
+-Q theories/program_logic     hazel.program_logic
+-Q theories/case_studies      hazel.case_studies
 
--arg -w -arg -convert_concl_no_check
+-arg "-w -redundant-canonical-projection -w -notation-incompatible-prefix -w -notation-both-format-and-spaces"
 
 theories/lib/lib.v
 
@@ -26,8 +25,6 @@ theories/program_logic/deep_handler_reasoning.v
 theories/program_logic/reasoning_rules.v
 theories/program_logic/adequacy.v
 
-theories/program_logic_ext/named_effects.v
-
 theories/case_studies/list_lib.v
 theories/case_studies/queue_lib.v
 theories/case_studies/map_lib.v
@@ -41,4 +38,3 @@ theories/case_studies/state.v
 theories/case_studies/shift_reset.v
 theories/case_studies/asynchronous_computation.v
 theories/case_studies/automatic_differentiation.v
-theories/case_studies/ml_references.v
diff --git a/opam b/opam
index 4e3a2c2..8bc9582 100644
--- a/opam
+++ b/opam
@@ -10,6 +10,6 @@ build: [make "-j%{jobs}%"]
 install: [make "install"]
 remove: [ "sh" "-c" "rm -rf '%{lib}%/coq/user-contrib/hazel" ]
 depends: [
-  "coq" { (= "8.13.0") }
-  "coq-iris-heap-lang" { (= "dev.2022-01-15.0.52c80aad") }
+  "coq" { (= "8.20.0") }
+  "coq-iris-heap-lang" { (= "dev.2024-10-07.0.6dece417") }
 ]
diff --git a/theories/case_studies/asynchronous_computation.v b/theories/case_studies/asynchronous_computation.v
index 9fec708..3118566 100644
--- a/theories/case_studies/asynchronous_computation.v
+++ b/theories/case_studies/asynchronous_computation.v
@@ -22,8 +22,8 @@
 From iris.proofmode Require Import base tactics classes.
 From iris.algebra Require Import excl_auth gset gmap agree.
 From iris.base_logic.lib Require Import iprop wsat invariants.
-From program_logic Require Import reasoning_rules.
-From case_studies Require Import list_lib queue_lib.
+From hazel.program_logic Require Import reasoning_rules.
+From hazel.case_studies Require Import list_lib queue_lib.
 
 
 (* ========================================================================== *)
@@ -145,9 +145,9 @@ End specification.
 
 (* The assumption that certain cameras are available. *)
 Class promiseGpreS Σ := {
-  promise_mapG :> inG Σ
+  promise_mapG :: inG Σ
     (authR (gmapUR (loc * gname) (agreeR (laterO (val -d> (iPropO Σ))))));
-  torchG :> inG Σ (exclR unitO);
+  torchG :: inG Σ (exclR unitO);
 }.
 
 (* A concrete instance of [Σ] for which the assumption [promisesGS Σ] holds. *)
@@ -162,7 +162,7 @@ Instance subG_promiseΣ {Σ} : subG promiseΣ Σ → promiseGpreS Σ.
 Proof. solve_inG. Qed.
 
 Class promiseGS Σ := {
-  promise_inG :> promiseGpreS Σ;
+  promise_inG :: promiseGpreS Σ;
   promise_name : gname;
 }.
 
@@ -318,7 +318,7 @@ Section predicates.
     Proof. by iMod (own_alloc (Excl tt)) as (γ) "Htorch"; last iExists γ. Qed.
 
     Lemma claim_uniqueness γ : (torch γ ∗ torch γ) -∗ False.
-    Proof. by rewrite /torch -own_op own_valid excl_validI. Qed.
+    Proof. rewrite /torch -own_op own_valid excl_validI. iIntros "$". Qed.
 
   End torch.
 
@@ -387,7 +387,7 @@ Section predicates.
       iIntros "Hp Hp'".
       iPoseProof (Haux with "Hp")  as "[%v  Hp]".
       iPoseProof (Haux with "Hp'") as "[%v' Hp']".
-      by iDestruct (mapsto_ne with "Hp Hp'") as "%Hneq".
+      by iDestruct (pointsto_ne with "Hp Hp'") as "%Hneq".
     Qed.
 
     Lemma promiseSt_proper' q p γ Φ Φ' :
@@ -405,7 +405,7 @@ Section predicates.
         iDestruct "HInv" as "[Hp' _]".
         by iDestruct (promiseSt_non_duplicable with "Hp Hp'") as "HFalse".
       - iMod (update_promise_map M p γ Φ Hlkp with "HM") as "[HM Hmem]".
-        iModIntro. iFrame. iExists (<[(p, γ):=Φ]> M). iFrame.
+        iModIntro. iFrame. 
         rewrite big_opM_insert; last done. by iFrame.
     Qed.
 
diff --git a/theories/case_studies/automatic_differentiation.v b/theories/case_studies/automatic_differentiation.v
index 9fbd695..b008c54 100644
--- a/theories/case_studies/automatic_differentiation.v
+++ b/theories/case_studies/automatic_differentiation.v
@@ -1,8 +1,8 @@
 (* automatic_differentiation.v *)
 
-From iris.algebra Require Import gmap_view.
+From iris.algebra Require Import gmap_view agree.
 From iris.proofmode Require Import base tactics classes.
-From program_logic Require Import reasoning_rules.
+From hazel.program_logic Require Import reasoning_rules.
 
 Set Default Proof Using "Type".
 
@@ -204,9 +204,9 @@ Class RingSig (R : Set) := {
 }.
 
 Class IsRing (R : Set) {RS : RingSig R} := {
-  r_eq_equiv :> Equivalence r_eq;
-  r_add_ext  :> Proper (r_eq ==> r_eq ==> r_eq) r_add;
-  r_mul_ext  :> Proper (r_eq ==> r_eq ==> r_eq) r_mul;
+  r_eq_equiv :: Equivalence r_eq;
+  r_add_ext  :: Proper (r_eq ==> r_eq ==> r_eq) r_add;
+  r_mul_ext  :: Proper (r_eq ==> r_eq ==> r_eq) r_mul;
 
   is_semi_ring : semi_ring_theory r_zero r_one r_add r_mul r_eq
 }.
@@ -1017,11 +1017,11 @@ Section camera.
   Canonical Structure nodeO := leibnizO node.
 
   Class cgraphG Σ := {
-    cgraph_mapG :> inG Σ (gmap_viewR val nodeO);
+    cgraph_mapG :: inG Σ (gmap_viewR val (agreeR nodeO));
   }.
 
   Definition cgraphΣ := #[
-    GFunctor (gmap_viewR val nodeO)
+    GFunctor (gmap_viewR val (agreeR nodeO))
   ].
 
   Instance subG_cgraphΣ {Σ} : subG cgraphΣ Σ → cgraphG Σ.
@@ -1038,8 +1038,8 @@ End camera.
 Section ghost_theory.
   Context `{!cgraphG Σ}.
 
-  Definition context_to_map (K : context) : gmap val node :=
-    list_to_map (reverse K).
+  Definition context_to_map (K : context) : gmap val (agreeR nodeO) :=
+    to_agree <$> (list_to_map (reverse K)).
 
   (* We wish to conceive an assertion [isContext K] to state that the sequence
      of arithmetic operations performed by the program being differentiated is
@@ -1058,7 +1058,7 @@ Section ghost_theory.
 
     ∧ (□ ∀ K B,
          isContext K -∗ isBinding B -∗
-           ⌜ context_to_map K !! B.1 = Some B.2 ⌝)
+           ⌜ context_to_map K !! B.1 = Some (to_agree B.2) ⌝)
 
     ∧ (□ ∀ B, isBinding B -∗ □ isBinding B)
 
@@ -1080,7 +1080,7 @@ Section ghost_theory.
     Lemma exploit_binding :
       pers_axioms isContext isBinding -∗
         □ ∀ K B, isContext K -∗ isBinding B -∗
-          ⌜ context_to_map K !! B.1 = Some B.2 ⌝.
+          ⌜ context_to_map K !! B.1 = Some (to_agree B.2) ⌝.
     Proof. by iIntros "(_&$&_)". Qed.
 
     Lemma new_binding :
@@ -1098,14 +1098,14 @@ Section ghost_theory.
   End isContext_and_isBinding_properties.
 
   Definition isContextRaw (γ : gname) (K : context) : iProp Σ :=
-    own γ (gmap_view_auth (V:=nodeO) (DfracOwn 1) (context_to_map K)).
+    own γ (gmap_view_auth (V:=(agreeR nodeO)) (DfracOwn 1) (context_to_map K)).
 
   Definition isBindingRaw (γ : gname) (B : binding) : iProp Σ :=
-    own γ (gmap_view_frag (V:=nodeO) B.1 DfracDiscarded B.2).
+    own γ (gmap_view_frag (V:=(agreeR nodeO)) B.1 DfracDiscarded (to_agree B.2)).
 
   Lemma alloc_context_var : ⊢ |==> ∃ γ, isContextRaw γ [].
   Proof.
-    iMod (own_alloc (gmap_view_auth (V:=nodeO) (DfracOwn 1) ∅)) as (γ) "Hauth".
+    iMod (own_alloc (gmap_view_auth (V:=agreeR nodeO) (DfracOwn 1) ∅)) as (γ) "Hauth".
     { by apply gmap_view_auth_valid. }
     { by eauto. }
   Qed.
@@ -1123,11 +1123,16 @@ Section ghost_theory.
     { iIntros "Hauth". rewrite -own_op.
       iApply own_update. unfold context_to_map.
       rewrite reverse_app. simpl.
+      rewrite fmap_insert.
       by apply gmap_view_alloc. done.
     }
     { iIntros "Hauth Hfrag".
-      by iDestruct (own_valid_2 with "Hauth Hfrag")
-        as %[_[_?]]%gmap_view_both_dfrac_valid_L.
+      iDestruct (own_valid_2 with "Hauth Hfrag") as "%H".
+      destruct (gmap_view_both_dfrac_valid_discrete_total _ _ _ _ _ H) as (v & _ & _ & Hlookup & _ & Hagree).
+      rewrite Hlookup. rewrite /context_to_map lookup_fmap_Some in Hlookup.
+      destruct Hlookup as (x & <- & _).
+      destruct (to_agree_included_L B.2 x) as [Heq _].
+      by rewrite Heq.
     }
     { by iIntros. }
   Qed.
@@ -1327,7 +1332,7 @@ Section general_facts.
         iDestruct "Hu"  as (???) "[Hu  ->]".
         iDestruct "Hu'" as (???) "[Hu' %]".
         rename H into Heq. inversion Heq.
-        by iDestruct (mapsto_ne with "Hu Hu'") as "%".
+        by iDestruct (pointsto_ne with "Hu Hu'") as "%".
       }
       iDestruct ("IH" with "Hus") as "%". rename H0 into HNoDup.
       iPureIntro. by apply NoDup_cons_2.
@@ -1527,8 +1532,9 @@ Section forward_invariant.
     iIntros "#Haxioms [Hauth Hrest]". simpl.
     iDestruct 1 as (a b) "(Hfrag&Ha&Hb)".
     iDestruct (exploit_binding with "Haxioms Hauth Hfrag") as %Hlkp. iFrame.
-    iExists a, b. iFrame.
     iPureIntro. rewrite -elem_of_reverse.
+    rewrite /context_to_map lookup_fmap_Some in Hlkp.
+    destruct Hlkp as (n & Heq & H). inv Heq.
     by apply (elem_of_list_to_map_2 (K:=val) (M:=gmap val)).
   Qed.
 
@@ -1713,7 +1719,7 @@ Section forward_invariant.
       iDestruct "Hheap" as "[Hy Hheap]".
       iDestruct "Hy" as (v' ℓ') "[_ [Hy ->]]".
       iSplit.
-      { iDestruct (mapsto_ne with "Hu Hy") as %H.
+      { iDestruct (pointsto_ne with "Hu Hy") as %H.
         iPureIntro. inversion 1. contradiction. }
       { by iApply ("IH" with "Hu Hheap"). }
     }
@@ -1726,7 +1732,8 @@ Section forward_invariant.
   Proof using isBinding.
     iIntros "Hx Hinv" (v).
     iDestruct (forward_inv_fresh_loc with "Hx Hinv") as %Hnot_in.
-    iPureIntro. apply not_elem_of_list_to_map_1. set_solver.
+    iPureIntro. rewrite /context_to_map lookup_fmap.
+    rewrite not_elem_of_list_to_map_1; first done. set_solver.
   Qed.
 
   Lemma forward_inv_update K x op a b v (ℓ : loc) el er :
@@ -1795,7 +1802,8 @@ Section forward_invariant_alloc.
     iSplit; [done|iSplit].
     { iPureIntro. intros ?. by rewrite elem_of_nil. }
     { rewrite //=.
-      iSplit; [|done]. iExists nᵣ, ℓₓ. iFrame.
+      iSplit; [done|iSplit]; last done. iExists nᵣ. 
+      iSplit; last done. 
       rewrite overwrite_neq; [|done].
       rewrite overwrite_neq; [|done].
       by iFrame.
@@ -2070,16 +2078,16 @@ Section proof_of_handle.
     iDestruct (adj_var_cases with "Haxioms Hinv Hu") as %Hcases.
     unfold get_v. ewp_pure_steps.
     destruct Hcases as [Hu|[Hu|Hu]]; try rewrite Hu.
-    { iDestruct "Hinv" as "(? & ? & Hheap)".
+    { iDestruct "Hinv" as "(H & HH & Hheap)".
       destruct (elem_of_list_lookup_1 _ _ Hu) as [i Hi].
       rewrite (big_sepL_delete' _ _ _ _ Hi).
       iDestruct "Hheap" as "[Hu' Hheap]".
       iDestruct "Hu'" as (v ℓ) "(Hv & ? & ->)".
       iDestruct (isNum_pers with "HisDict Hv") as "#?".
-      ewp_pure_steps. iFrame.
+      ewp_pure_steps. iFrame "H HH Hv".
       rewrite (big_sepL_delete' (λ _ u, ∃ _ _, _)%I _ _ _ Hi).
       iFrame. fold ϱ.
-      iExists v, ℓ. iFrame. by iSplit.
+      iExists v. iFrame. by iSplit.
     }
     { ewp_pure_steps. iFrame.
       rewrite extension_alt filling_undefined; [|done]. simpl.
@@ -2451,7 +2459,6 @@ Section proof_of_handle.
         iApply ewp_mono; [iApply mk_spec|].
         iIntros (x'). iDestruct 1 as (x) "[-> Hx]".
         iDestruct (forward_inv_fresh_loc with "Hx Hinv") as %Hx.
-        Check (forward_inv_update _ _ _ _ _ _ _ _ Add).
         iMod ((forward_inv_update _ _ _ _ _ _ _ _ Add)
           with "Haxioms Hinv Ha Hb [] Hx") as "[Hinv Hx'']"; [done| |].
         { fold ϱ. rewrite extension_snoc //= overwrite_eq. by iApply "Hxv". }
diff --git a/theories/case_studies/callcc.v b/theories/case_studies/callcc.v
index ed61aa5..d0b24fd 100644
--- a/theories/case_studies/callcc.v
+++ b/theories/case_studies/callcc.v
@@ -5,8 +5,8 @@
 From iris.proofmode Require Import base tactics classes.
 From iris.base_logic.lib Require Import iprop.
 From iris.program_logic Require Import weakestpre.
-From language Require Import eff_lang.
-From program_logic Require Import reasoning_rules.
+From hazel.language Require Import eff_lang.
+From hazel.program_logic Require Import reasoning_rules.
 
 
 (* ========================================================================== *)
@@ -69,9 +69,9 @@ Section specification.
     Local Instance CALLCC_pre_contractive : Contractive CALLCC_pre.
     Proof.
       rewrite /CALLCC_pre => n CALLCC CALLCC' HI.
-      by repeat (apply iEffPre_base_ne ||
-                 rewrite iEffPost_base_eq || unfold iEffPost_base_def ||
-                 apply HI || f_contractive || f_equiv || intros =>?).
+      do 7 f_equiv.
+      { f_equiv. f_contractive. by do 2 f_equiv. }
+      intros ?. f_equiv. f_contractive. by do 2 f_equiv.
     Qed.
     Definition CALLCC_def : iEff Σ := fixpoint (CALLCC_pre).
     Definition CALLCC_aux : seal CALLCC_def. Proof. by eexists. Qed.
@@ -341,7 +341,7 @@ Section shift_reset.
       iApply (ewp_store with "Hk'").
       iIntros "!> Hmc !>". simpl. ewp_pure_steps.
       iApply (ewp_throw with "[Hy Hm Hmc] Hk").
-      iFrame. iExists m. by iFrame.
+      iFrame.
     }
     by iApply (abort_spec with "Ht").
   Qed.
diff --git a/theories/case_studies/control_inversion.v b/theories/case_studies/control_inversion.v
index 9bc4c3c..aca48c5 100644
--- a/theories/case_studies/control_inversion.v
+++ b/theories/case_studies/control_inversion.v
@@ -27,9 +27,9 @@
 From stdpp Require Import list.
 From iris.proofmode Require Import base tactics classes.
 From iris.algebra Require Import excl_auth.
-From language Require Import eff_lang.
-From program_logic Require Import reasoning_rules.
-From case_studies Require Import iteration callcc.
+From hazel.language Require Import eff_lang.
+From hazel.program_logic Require Import reasoning_rules.
+From hazel.case_studies Require Import iteration callcc.
 
 
 (* ========================================================================== *)
@@ -309,7 +309,7 @@ Section verification.
         iIntros "!> Hr !>". simpl.
         ewp_pure_steps.
         iApply (ewp_throw with "[Hr Hrepr] Hkp"). simpl.
-        iFrame. iExists kc'. by iFrame.
+        iFrame. by iFrame.
       - iIntros "!#" (v) "[Hrepr [%Xs [[%kc [Hr #Hkc]] #Hcomplete]]] !>". simpl.
         ewp_pure_steps. ewp_bind_rule.
         iApply (ewp_load with "Hr").
diff --git a/theories/case_studies/exceptions.v b/theories/case_studies/exceptions.v
index e98c9ad..ee5d023 100644
--- a/theories/case_studies/exceptions.v
+++ b/theories/case_studies/exceptions.v
@@ -5,7 +5,7 @@
    exceptions. *)
 
 From iris.proofmode Require Import base tactics classes.
-From program_logic Require Import reasoning_rules.
+From hazel.program_logic Require Import reasoning_rules.
 
 
 (* ========================================================================== *)
diff --git a/theories/case_studies/iteration.v b/theories/case_studies/iteration.v
index f824940..5577843 100644
--- a/theories/case_studies/iteration.v
+++ b/theories/case_studies/iteration.v
@@ -7,9 +7,9 @@
    iteration methods and lazy sequences. *)
 
 From iris.proofmode Require Import base tactics classes.
-From language Require Import eff_lang.
-From program_logic Require Import reasoning_rules.
-From case_studies Require Import list_lib.
+From hazel.language Require Import eff_lang.
+From hazel.program_logic Require Import reasoning_rules.
+From hazel.case_studies Require Import list_lib.
 
 Set Default Proof Using "Type".
 
@@ -25,7 +25,7 @@ Class Representable Σ (A : Type) :=
 (* A representable type [A] is persistently representable
    if its representation predicate holds persistently. *)
 Class PersRepresentable Σ A `{Representable Σ A} :=
-  pers_representable x X :> Persistent (represents x X).
+  pers_representable x X :: Persistent (represents x X).
 
 
 (* ========================================================================== *)
@@ -34,12 +34,12 @@ Class PersRepresentable Σ A `{Representable Σ A} :=
 (* We formalize a data structure as a type family [G], such that
    [G A] is representable for every repesentable type [A]. *)
 Class DataStructure Σ (G : Type → Type) :=
-  is_representable A `{Representable Σ A} :> Representable Σ (G A).
+  is_representable A `{Representable Σ A} :: Representable Σ (G A).
 
 (* A data structure [G] is persistent if [G A] is persistently
    representable for every persistently representable type [A]. *)
 Class PersStructure Σ G `{DataStructure Σ G} :=
-  is_pers_representable A `{PersRepresentable Σ A} :>
+  is_pers_representable A `{PersRepresentable Σ A} ::
     PersRepresentable Σ (G A).
 
 
diff --git a/theories/case_studies/list_lib.v b/theories/case_studies/list_lib.v
index d02f3fe..331408f 100644
--- a/theories/case_studies/list_lib.v
+++ b/theories/case_studies/list_lib.v
@@ -6,7 +6,7 @@
 
 From stdpp Require Import list.
 From iris.proofmode Require Import base tactics classes.
-From program_logic Require Import reasoning_rules.
+From hazel.program_logic Require Import reasoning_rules.
 
 
 (* ========================================================================== *)
diff --git a/theories/case_studies/map_lib.v b/theories/case_studies/map_lib.v
index e1e4c3a..0232120 100644
--- a/theories/case_studies/map_lib.v
+++ b/theories/case_studies/map_lib.v
@@ -2,7 +2,7 @@
 
 (* This file introduces a simple API exposing operations to manipulate maps. *)
 
-From program_logic Require Import reasoning_rules.
+From hazel.program_logic Require Import reasoning_rules.
 
 
 (* ========================================================================== *)
diff --git a/theories/case_studies/ml_references.v b/theories/case_studies/ml_references.v
deleted file mode 100644
index e69de29..0000000
diff --git a/theories/case_studies/queue_lib.v b/theories/case_studies/queue_lib.v
index 2be9a8b..39b6f72 100644
--- a/theories/case_studies/queue_lib.v
+++ b/theories/case_studies/queue_lib.v
@@ -5,8 +5,8 @@
 From stdpp Require Import list.
 From iris.proofmode Require Import base tactics classes.
 From iris.program_logic Require Import weakestpre.
-From program_logic Require Import reasoning_rules.
-From case_studies Require Import list_lib.
+From hazel.program_logic Require Import reasoning_rules.
+From hazel.case_studies Require Import list_lib.
 
 
 (* ========================================================================== *)
@@ -145,7 +145,7 @@ Section QueueLibModel.
     simpl. ewp_pure_steps. ewp_bind_rule.
     iApply (ewp_store with "Hl"). iIntros "!> Hl !>".
     simpl. ewp_pure_steps.
-    iFrame. iExists l, us. by eauto with iFrame.
+    iFrame. eauto.
   Qed.
 
   Lemma queue_empty_spec' E Ψ1 Ψ2 q I n :
diff --git a/theories/case_studies/sat.v b/theories/case_studies/sat.v
index bab218c..4e0b19c 100644
--- a/theories/case_studies/sat.v
+++ b/theories/case_studies/sat.v
@@ -5,8 +5,8 @@
 
 From iris.proofmode Require Import base tactics classes.
 From iris.algebra Require Import excl_auth agree gset gmap agree.
-From program_logic Require Import reasoning_rules.
-From case_studies Require Import map_lib.
+From hazel.program_logic Require Import reasoning_rules.
+From hazel.case_studies Require Import map_lib.
 
 
 (* ========================================================================== *)
@@ -200,9 +200,9 @@ Proof.
   }
   (* Lit. *)
   { destruct (M !! i) as [b|] eqn:?.
-    { by rewrite (map_filter_lookup_Some_2 _ _ _ _ Heqo);
+    { by rewrite (map_lookup_filter_Some_2 _ _ _ _ Heqo);
          [|rewrite elem_of_list_singleton ]. }
-    { by rewrite (map_filter_lookup_None_2 _ _ i); [|left]. }
+    { by rewrite (map_lookup_filter_None_2 _ _ i); [|left]. }
   }
 Qed.
 
@@ -235,7 +235,7 @@ Qed.
    [M'] of indices in [js] such that [eval (M ∪ M') p] is true. *)
 Lemma sat_proc_spec' p M js :
   sat_proc' p M js = true ↔
-    ∃ M', elements (dom (gset nat) M') ⊆ js ∧ eval (M ∪ M') p = Some true.
+    ∃ M', elements (dom M') ⊆ js ∧ eval (M ∪ M') p = Some true.
 Proof.
   (* Proof by induction on the list of indices [js]. *)
   revert js M. induction js as [|j js]; intro M.
@@ -251,7 +251,7 @@ Proof.
   - (* Case [j :: js]. *)
     simpl.
     have Haux: (∃ b, sat_proc' p (M ∪ {[j:=b]}) js = true) ↔
-      (∃ M', elements (dom (gset nat) M') ⊆ j :: js ∧
+      (∃ M', elements (dom M') ⊆ j :: js ∧
              eval (M ∪ M') p = Some true).
     { split; [intros [b Hsat]|intros [M' [Hdom Heval]]].
       { revert Hsat. rewrite IHjs. intros [M' [Hdom Heval]].
@@ -293,7 +293,7 @@ Proof.
     exists (filter (λ '(i, _), i ∈ indices p) M'). split.
     { intro i. rewrite elem_of_elements elem_of_dom.
       intros [b Hlkup]. revert Hlkup.
-      rewrite map_filter_lookup_Some. by intros [_ ?].
+      rewrite map_lookup_filter_Some. by intros [_ ?].
     }
     { rewrite -Heval eval_restriction (eval_restriction (M ∪ M')).
       have Haux: ∀ M', filter (λ '(i, _), i ∈ indices p) (M ∪ M') =
@@ -304,24 +304,24 @@ Proof.
         destruct (M !! i) as [b|] eqn:?; [|
         destruct (M' !! i) as [b'|] eqn:? ] |].
         { transitivity (Some b); [
-          by rewrite map_filter_lookup_Some (lookup_union_Some_l _ _ i b)|].
+          by rewrite map_lookup_filter_Some (lookup_union_Some_l _ _ i b)|].
           symmetry.
-          rewrite lookup_union_Some_raw map_filter_lookup_Some.
+          rewrite lookup_union_Some_raw map_lookup_filter_Some.
           by left.
         }
         { transitivity (Some b'); [
-          by rewrite map_filter_lookup_Some lookup_union_r|].
+          by rewrite map_lookup_filter_Some lookup_union_r|].
           symmetry. rewrite lookup_union_Some_raw. right.
-          rewrite map_filter_lookup_None map_filter_lookup_Some. by auto.
+          rewrite map_lookup_filter_None map_lookup_filter_Some. by auto.
         }
         { transitivity (@None bool); [
-          by rewrite map_filter_lookup_None lookup_union_r; [left|] |].
-          symmetry. rewrite lookup_union_None !map_filter_lookup_None.
+          by rewrite map_lookup_filter_None lookup_union_r; [left|] |].
+          symmetry. rewrite lookup_union_None !map_lookup_filter_None.
           split; by left.
         }
         { transitivity (@None bool); [
-          rewrite map_filter_lookup_None; by right|].
-          symmetry. rewrite lookup_union_None !map_filter_lookup_None.
+          rewrite map_lookup_filter_None; by right|].
+          symmetry. rewrite lookup_union_None !map_lookup_filter_None.
           split; by right.
         }
       }
@@ -458,7 +458,7 @@ End specification.
 (* Camera. *)
 
 Class satG Σ := {
-  assignmentG :> inG Σ (excl_authR (gmapO natO boolO));
+  assignmentG :: inG Σ (excl_authR (gmapO natO boolO));
 }.
 Definition satΣ := #[ GFunctor (excl_authR (gmapO natO boolO)) ].
 Instance subG_interpΣ {Σ} : subG satΣ Σ → satG Σ.
@@ -558,13 +558,13 @@ Section map_lib.
     { by iApply (map_insert_spec with "Hm"). }
     iIntros "!#" (_) "Hm". iModIntro. iExists (<[#i:=#b]> M'). iFrame.
     iPureIntro. split; intro j; [intro b'|];
-    case (nat_eq_dec i j) as [->|];
+    case (Nat.eq_dec i j) as [->|];
     try (rewrite !lookup_insert; by inversion 1).
     { rewrite !lookup_insert_ne; [apply H| |done]; intro Heq; apply n;
-      inversion Heq; by apply Z_of_nat_inj.
+      inversion Heq; by apply Znat.Nat2Z.inj.
     }
     { rewrite !lookup_insert_ne; [apply H0| |done]; intro Heq; apply n;
-      inversion Heq; by apply Z_of_nat_inj.
+      inversion Heq; by apply Znat.Nat2Z.inj.
     }
   Qed.
 
@@ -578,11 +578,11 @@ Section map_lib.
     { by iApply (map_delete_spec with "Hm"). }
     iIntros "!#" (_) "Hm". iModIntro. iExists (delete #i M'). iFrame.
     iPureIntro. split; intro j; [intro b'|];
-    case (nat_eq_dec i j) as [->|]; try (rewrite !lookup_delete; by inversion 1).
+    case (Nat.eq_dec i j) as [->|]; try (rewrite !lookup_delete; by inversion 1).
     { rewrite !lookup_delete_ne; [apply H| |done]; intro Heq; apply n;
-      inversion Heq; by apply Z_of_nat_inj.  }
+      inversion Heq; by apply Znat.Nat2Z.inj.  }
     { rewrite !lookup_delete_ne; [apply H0| |done]; intro Heq; apply n;
-      inversion Heq; by apply Z_of_nat_inj.
+      inversion Heq; by apply Znat.Nat2Z.inj.
     }
   Qed.
 
@@ -636,7 +636,7 @@ Section interp.
       iExists M, i. iFrame. iSplit; [done|].
       iIntros "!#" (b) "[%Hb HM]". unfold interp_sign. ewp_pure_steps.
       assert (M ∪ {[i:=b]} = <[i:=b]> M) as Haux.
-      { apply map_eq. intro j. case (nat_eq_dec i j) as [->|].
+      { apply map_eq. intro j. case (Nat.eq_dec i j) as [->|].
         { by rewrite lookup_insert -Hb lookup_union lookup_singleton;
           case (M !! j). }
         { rewrite lookup_insert_ne; [|done].
diff --git a/theories/case_studies/shallow_as_deep.v b/theories/case_studies/shallow_as_deep.v
index 633478a..7139bdf 100644
--- a/theories/case_studies/shallow_as_deep.v
+++ b/theories/case_studies/shallow_as_deep.v
@@ -11,7 +11,7 @@
    to make an assumption: effects are either all one-shot or all multi-shot. *)
 
 From iris.proofmode Require Import base tactics classes.
-From program_logic Require Import reasoning_rules.
+From hazel.program_logic Require Import reasoning_rules.
 
 
 (* ========================================================================== *)
diff --git a/theories/case_studies/shift_reset.v b/theories/case_studies/shift_reset.v
index 5a50ddc..d2ac201 100644
--- a/theories/case_studies/shift_reset.v
+++ b/theories/case_studies/shift_reset.v
@@ -4,7 +4,7 @@
    [shift0/reset0] and [shift/reset]. *)
 
 From iris.proofmode Require Import base tactics classes.
-From program_logic Require Import reasoning_rules.
+From hazel.program_logic Require Import reasoning_rules.
 
 
 (* ========================================================================== *)
@@ -103,9 +103,7 @@ Section specification.
     Local Instance shift_pre_contractive : Contractive SHIFT_pre.
     Proof.
       intros n SHIFT SHIFT' HS Ψ Φ. rewrite /SHIFT_pre /is_shift_pre.
-      by repeat (apply iEffPre_base_ne ||
-                 rewrite iEffPost_base_eq || unfold iEffPost_base_def ||
-                 apply HS || f_contractive || f_equiv || intros =>?).
+      do 8 f_equiv. f_contractive. by do 2 f_equiv.
     Qed.
     Definition SHIFT_def : iEffO -d> (val -d> iPropO Σ) -d>  iEffO :=
       fixpoint (SHIFT_pre).
diff --git a/theories/case_studies/state.v b/theories/case_studies/state.v
index eed15e4..86c0100 100644
--- a/theories/case_studies/state.v
+++ b/theories/case_studies/state.v
@@ -4,7 +4,7 @@
 
 From iris.proofmode Require Import base tactics classes.
 From iris.algebra Require Import excl_auth.
-From program_logic Require Import reasoning_rules.
+From hazel.program_logic Require Import reasoning_rules.
 
 
 (* ========================================================================== *)
diff --git a/theories/language/eff_lang.v b/theories/language/eff_lang.v
index 950f743..4dd9cb6 100644
--- a/theories/language/eff_lang.v
+++ b/theories/language/eff_lang.v
@@ -1,5 +1,5 @@
 (* eff_lang.v *)
 
-From language Require Export syntax notation semantics
-                             neutral_contexts properties
-                             iris_language.
+From hazel.language Require Export syntax notation semantics
+                                   neutral_contexts properties
+                                   iris_language.
diff --git a/theories/language/iris_language.v b/theories/language/iris_language.v
index eb055d1..9c06cc5 100644
--- a/theories/language/iris_language.v
+++ b/theories/language/iris_language.v
@@ -12,7 +12,7 @@
 *)
 
 From iris.program_logic Require Import language.
-From language Require Import syntax semantics neutral_contexts.
+From hazel.language Require Import syntax semantics neutral_contexts.
 
 
 (* ========================================================================== *)
diff --git a/theories/language/neutral_contexts.v b/theories/language/neutral_contexts.v
index 0d2b2ff..8c15e8d 100644
--- a/theories/language/neutral_contexts.v
+++ b/theories/language/neutral_contexts.v
@@ -7,7 +7,7 @@
    [program_logic/weakest_precondition.v].
 *)
 
-From language Require Import syntax semantics.
+From hazel.language Require Import syntax semantics.
 
 (* ========================================================================== *)
 (** * Definition of Neutral Contexts. *)
diff --git a/theories/language/notation.v b/theories/language/notation.v
index b224bed..3840707 100644
--- a/theories/language/notation.v
+++ b/theories/language/notation.v
@@ -5,7 +5,7 @@
 *)
 
 From iris.program_logic Require Import language.
-From language Require Export syntax.
+From hazel.language Require Export syntax.
 
 Set Default Proof Using "Type".
 
diff --git a/theories/language/properties.v b/theories/language/properties.v
index 6ef98a9..a779699 100644
--- a/theories/language/properties.v
+++ b/theories/language/properties.v
@@ -3,8 +3,8 @@
 (* This file collects general facts about [eff_lang] and its
    related definitions. *)
 
-From lib Require Export lib.
-From language Require Import syntax.
+From hazel.lib Require Export lib.
+From hazel.language Require Import syntax.
 
 (* ========================================================================== *)
 (** * Markers. *)
diff --git a/theories/language/semantics.v b/theories/language/semantics.v
index df0a138..97a296d 100644
--- a/theories/language/semantics.v
+++ b/theories/language/semantics.v
@@ -31,7 +31,7 @@
 
 *)
 
-From language Require Import syntax.
+From hazel.language Require Import syntax.
 
 (* ========================================================================== *)
 (** * Preliminary Definitions. *)
@@ -499,29 +499,29 @@ Proof. destruct 1; eauto. Qed.
 
 (* There is always a fresh location to be used by [Alloc v]. *)
 Lemma alloc_fresh v σ :
-  let l := fresh_locs (dom (gset loc) σ.(heap)) in
+  let l := Loc.fresh (dom σ.(heap)) in
   head_step (Alloc (Val v))                            σ
             (Val $ LitV $ LitLoc l) (heap_upd <[l:=v]> σ).
 Proof.
   intros.
   apply AllocS.
   intros. apply (not_elem_of_dom (D := gset loc)).
-  specialize (fresh_locs_fresh (dom _ (heap σ)) 0).
-  rewrite loc_add_0. naive_solver.
+  specialize (Loc.fresh_fresh (dom (heap σ)) 0).
+  rewrite Loc.add_0. naive_solver.
 Qed.
 
 (* There is always a fresh location to be used in the
    creation of a new one-shot continuation. *)
 Lemma try_with_fresh h r v k σ :
- let l := fresh_locs (dom (gset loc) σ.(heap)) in
+ let l := Loc.fresh (dom σ.(heap)) in
  head_step (TryWith (Eff OS v k) h r)           σ
            (App (App h (Val v)) (Val (ContV k l)))
            (heap_upd <[l:=LitV $ LitBool false]> σ).
 Proof.
   intros. apply TryWithOSEffS.
   intros. apply (not_elem_of_dom (D := gset loc)).
-  specialize (fresh_locs_fresh (dom _ (heap σ)) 0).
-  rewrite loc_add_0. naive_solver.
+  specialize (Loc.fresh_fresh (dom (heap σ)) 0).
+  rewrite Loc.add_0. naive_solver.
 Qed.
 
 Lemma Ectxi_prim_step_inv f e e₂ σ₁ σ₂ :
diff --git a/theories/language/syntax.v b/theories/language/syntax.v
index 3d0b3e7..241cd78 100644
--- a/theories/language/syntax.v
+++ b/theories/language/syntax.v
@@ -32,8 +32,10 @@ From iris.heap_lang Require Export locations. (* Domain of locations. *)
 
 Set Default Proof Using "Type".
 
+Declare Scope expr_scope.
 Delimit Scope expr_scope with E.
-Delimit Scope val_scope  with V.
+Declare Scope val_scope.
+Delimit Scope val_scope with V.
 
 
 (* ========================================================================== *)
diff --git a/theories/program_logic/adequacy.v b/theories/program_logic/adequacy.v
index 42a5963..36ab5fd 100644
--- a/theories/program_logic/adequacy.v
+++ b/theories/program_logic/adequacy.v
@@ -11,7 +11,7 @@
 From iris.proofmode Require Import base tactics classes.
 From iris.base_logic.lib Require Import iprop wsat.
 From iris.program_logic Require Import weakestpre adequacy.
-From program_logic Require Import reasoning_rules.
+From hazel.program_logic Require Import reasoning_rules.
 
 
 (* ========================================================================== *)
@@ -43,7 +43,7 @@ Proof.
     case k   as [|??]; [|done].
     case efs as [|??]; [|done].
     simpl in Hstep.
-    iMod ("H" with "[//]") as "H". iIntros "!> !>".
+    iMod ("H" with "[//]") as "H". iIntros "_ !> !>".
     simpl. iMod "H". iModIntro.
     iApply (step_fupdN_wand with "[H]"); first by iApply "H".
     iIntros "H". iMod "H" as "[$ Hewp]". iModIntro.
diff --git a/theories/program_logic/basic_reasoning_rules.v b/theories/program_logic/basic_reasoning_rules.v
index 8ec106b..5bf4a45 100644
--- a/theories/program_logic/basic_reasoning_rules.v
+++ b/theories/program_logic/basic_reasoning_rules.v
@@ -9,7 +9,7 @@
 
 From iris.proofmode Require Import base tactics classes.
 From iris.program_logic Require Import weakestpre.
-From program_logic Require Import weakest_precondition.
+From hazel.program_logic Require Import weakest_precondition.
 
 
 (* ========================================================================== *)
@@ -46,12 +46,12 @@ Section reasoning_rules.
     iEff_car (upcl OS Ψ1) v (λ w,
       ▷ EWP fill k (Val w) @ E <| Ψ1 |> {| Ψ2 |} {{ Φ }}) -∗
     EWP of_eff OS v k @ E <| Ψ1 |> {| Ψ2 |} {{ Φ }}.
-  Proof. by rewrite ewp_eff_os_eq. Qed.
+  Proof. rewrite ewp_eff_os_eq. iIntros "$". Qed.
   Lemma ewp_eff_ms E Ψ1 Ψ2 Φ v k :
     iEff_car (upcl MS Ψ2) v (λ w,
       ▷ EWP fill k (Val w) @ E <| Ψ1 |> {| Ψ2 |} {{ Φ }}) -∗
     EWP of_eff MS v k @ E <| Ψ1 |> {| Ψ2 |} {{ Φ }}.
-  Proof. by rewrite ewp_eff_ms_eq. Qed.
+  Proof. rewrite ewp_eff_ms_eq. iIntros "$". Qed.
 
   (* Test. *)
   Goal forall A (P : A → iProp Σ) Φ (Ψ : iEff Σ) (v : val) x,
diff --git a/theories/program_logic/deep_handler_reasoning.v b/theories/program_logic/deep_handler_reasoning.v
index 56d7c0f..3ed41ec 100644
--- a/theories/program_logic/deep_handler_reasoning.v
+++ b/theories/program_logic/deep_handler_reasoning.v
@@ -3,9 +3,9 @@
 (* This file introduces reasoning rules for deep handlers. *)
 
 From iris.proofmode Require Import base tactics classes.
-From program_logic Require Import protocols weakest_precondition
-                                  basic_reasoning_rules state_reasoning
-                                  shallow_handler_reasoning tactics.
+From hazel.program_logic Require Import protocols weakest_precondition
+                                        basic_reasoning_rules state_reasoning
+                                        shallow_handler_reasoning tactics.
 
 (* ========================================================================== *)
 (** * Implementation. *)
@@ -102,7 +102,7 @@ Section deep_handler_judgment.
   Definition deep_handler := deep_handler_aux.(unseal).
   Definition deep_handler_eq : deep_handler = deep_handler_def
     := deep_handler_aux.(seal_eq).
-  Arguments deep_handler _ _%ieff _%ieff _%I _%V _%V _%ieff _%ieff _%I.
+  Arguments deep_handler _ _%_ieff _%_ieff _%_I _%_V _%_V _%_ieff _%_ieff _%_I.
 
   Global Lemma deep_handler_unfold E Ψ1 Ψ2 Φ h r Ψ1' Ψ2' Φ' :
     deep_handler E Ψ1 Ψ2 Φ h r Ψ1' Ψ2' Φ' ⊣⊢
diff --git a/theories/program_logic/protocols.v b/theories/program_logic/protocols.v
index 09ad69b..cf2b10b 100644
--- a/theories/program_logic/protocols.v
+++ b/theories/program_logic/protocols.v
@@ -9,7 +9,7 @@
 
 From iris.proofmode Require Import tactics.
 From iris.base_logic Require Export lib.iprop.
-From language Require Import eff_lang.
+From hazel.language Require Import eff_lang.
 
 Set Default Proof Using "Type".
 
@@ -134,7 +134,7 @@ Program Definition upcl {Σ} (m : mode) (Ψ : iEff Σ) : iEff Σ :=
 Next Obligation.
   intros ????????. by destruct m; simpl; repeat f_equiv.
 Defined.
-Arguments upcl _ _%ieff.
+Arguments upcl _ _%_ieff.
 
 
 (* -------------------------------------------------------------------------- *)
@@ -205,7 +205,7 @@ Definition iEffPre_base_aux : seal (@iEffPre_base_def). by eexists. Qed.
 Definition iEffPre_base := iEffPre_base_aux.(unseal).
 Definition iEffPre_base_eq : @iEffPre_base = @iEffPre_base_def :=
   iEffPre_base_aux.(seal_eq).
-Arguments iEffPre_base {_} _ _%V _%I _%ieff.
+Arguments iEffPre_base {_} _ _%_V _%_I _%_ieff.
 Instance: Params (@iEffPre_base) 4 := {}.
 
 (* Close a protocol with an existential quantifier. *)
@@ -216,13 +216,13 @@ Definition iEffPre_exist_aux : seal (@iEffPre_exist_def). by eexists. Qed.
 Definition iEffPre_exist := iEffPre_exist_aux.(unseal).
 Definition iEffPre_exist_eq : @iEffPre_exist = @iEffPre_exist_def :=
   iEffPre_exist_aux.(seal_eq).
-Arguments iEffPre_exist {_ _} _%ieff.
+Arguments iEffPre_exist {_ _} _%_ieff.
 Instance: Params (@iEffPre_exist) 3 := {}.
 
 (* Iterate the existential closure. *)
 Definition iEffPre_texist {Σ} {TT : tele} (e : TT → iEff Σ) : iEff Σ :=
   tele_fold (@iEffPre_exist Σ) (λ x, x) (tele_bind e).
-Arguments iEffPre_texist {_ _} _%ieff /.
+Arguments iEffPre_texist {_ _} _%_ieff /.
 
 (* Construct a predicate from a pair of a value [w] and an assertion [Q]. *)
 Definition iEffPost_base_def {Σ} (w : val) (Q : iProp Σ) : val -d> iPropO Σ
@@ -231,7 +231,7 @@ Definition iEffPost_base_aux : seal (@iEffPost_base_def). by eexists. Qed.
 Definition iEffPost_base := iEffPost_base_aux.(unseal).
 Definition iEffPost_base_eq : @iEffPost_base = @iEffPost_base_def :=
   iEffPost_base_aux.(seal_eq).
-Arguments iEffPost_base {_} _%V _%I.
+Arguments iEffPost_base {_} _%_V _%_I.
 Instance: Params (@iEffPost_base) 2 := {}.
 
 (* Close a predicate with an existential quantifier. *)
@@ -242,13 +242,13 @@ Definition iEffPost_exist_aux : seal (@iEffPost_exist_def). by eexists. Qed.
 Definition iEffPost_exist := iEffPost_exist_aux.(unseal).
 Definition iEffPost_exist_eq : @iEffPost_exist = @iEffPost_exist_def :=
   iEffPost_exist_aux.(seal_eq).
-Arguments iEffPost_exist {_ _} _%ieff.
+Arguments iEffPost_exist {_ _} _%_ieff.
 Instance: Params (@iEffPost_exist) 2 := {}.
 
 Definition iEffPost_texist {Σ} {TT : tele}
   (e : TT → (val -d> iPropO Σ)) : val -d> iPropO Σ :=
   tele_fold (@iEffPost_exist Σ) (λ x, x) (tele_bind e).
-Arguments iEffPost_texist {_ _} _%ieff /.
+Arguments iEffPost_texist {_ _} _%_ieff /.
 
 (* Protocol marked by a function [f]. *)
 Program Definition iEff_marker_def {Σ} (f : val → val) (e : iEff Σ) : iEff Σ :=
@@ -258,7 +258,7 @@ Definition iEff_marker_aux : seal (@iEff_marker_def). by eexists. Qed.
 Definition iEff_marker := iEff_marker_aux.(unseal).
 Definition iEff_marker_eq : @iEff_marker = @iEff_marker_def :=
   iEff_marker_aux.(seal_eq).
-Arguments iEff_marker {_} _ _%ieff.
+Arguments iEff_marker {_} _ _%_ieff.
 Instance: Params (@iEff_marker) 3 := {}.
 
 (* Extend a given protocol with the constraint
@@ -270,7 +270,7 @@ Definition iEff_filter_aux : seal (@iEff_filter_def). by eexists. Qed.
 Definition iEff_filter := iEff_filter_aux.(unseal).
 Definition iEff_filter_eq : @iEff_filter = @iEff_filter_def :=
   iEff_filter_aux.(seal_eq).
-Arguments iEff_filter {_} _ _%ieff.
+Arguments iEff_filter {_} _ _%_ieff.
 Instance: Params (@iEff_marker) 3 := {}.
 
 (* Protocol sum. *)
@@ -281,7 +281,7 @@ Definition iEff_sum_aux : seal (@iEff_sum_def). by eexists. Qed.
 Definition iEff_sum := iEff_sum_aux.(unseal).
 Definition iEff_sum_eq : @iEff_sum = @iEff_sum_def :=
   iEff_sum_aux.(seal_eq).
-Arguments iEff_sum {_} _%ieff _%ieff.
+Arguments iEff_sum {_} _%_ieff _%_ieff.
 Instance: Params (@iEff_sum) 3 := {}.
 
 
@@ -742,7 +742,7 @@ Section protocol_operators_properties.
   Proof.
     rewrite /upcl iEff_marker_eq.
     iIntros "H". iDestruct "H" as (Q) "[He HQ]".
-    iExists Q. iFrame. iExists v. by iFrame.
+    iExists Q. by iFrame.
   Qed.
 
   Lemma upcl_marker_elim f {Hf: Inj (=) (=) f} m v Ψ Φ :
diff --git a/theories/program_logic/reasoning_rules.v b/theories/program_logic/reasoning_rules.v
index 670dca0..3c50cf0 100644
--- a/theories/program_logic/reasoning_rules.v
+++ b/theories/program_logic/reasoning_rules.v
@@ -1,6 +1,6 @@
 (* reasoning_rules.v *)
 
-From program_logic Require Export protocols weakest_precondition
-                                  basic_reasoning_rules state_reasoning
-                                  shallow_handler_reasoning tactics
-                                  deep_handler_reasoning.
+From hazel.program_logic Require Export protocols weakest_precondition
+                                        basic_reasoning_rules state_reasoning
+                                        shallow_handler_reasoning tactics
+                                        deep_handler_reasoning.
diff --git a/theories/program_logic/shallow_handler_reasoning.v b/theories/program_logic/shallow_handler_reasoning.v
index 226541d..7287cd7 100644
--- a/theories/program_logic/shallow_handler_reasoning.v
+++ b/theories/program_logic/shallow_handler_reasoning.v
@@ -3,9 +3,9 @@
 (* This file introduces reasoning rules for shallow effect handlers. *)
 
 From iris.proofmode Require Import base tactics classes.
-From program_logic Require Import protocols weakest_precondition
-                                  basic_reasoning_rules
-                                  state_reasoning.
+From hazel.program_logic Require Import protocols weakest_precondition
+                                        basic_reasoning_rules
+                                        state_reasoning.
 
 
 (* ========================================================================== *)
@@ -165,7 +165,7 @@ Proof.
       iMod (fupd_mask_subseteq ∅) as "Hclose". by apply empty_subseteq.
       iModIntro. iSplitR.
       * iPureIntro. rewrite /reducible //=.
-        set (l := fresh_locs (dom (gset loc) σ.(heap))).
+        set (l := Loc.fresh (dom σ.(heap))).
         exists [], (h v (ContV k l)), (heap_upd <[l:=#false]> σ), []. simpl.
         apply (Ectx_prim_step _ _ _ _ []
               (TryWith (Eff OS v k) h r) (h v (ContV k l))); try done.
diff --git a/theories/program_logic/state_reasoning.v b/theories/program_logic/state_reasoning.v
index ddefd96..45e8334 100644
--- a/theories/program_logic/state_reasoning.v
+++ b/theories/program_logic/state_reasoning.v
@@ -10,8 +10,8 @@ From iris.bi.lib Require Import fractional.
 From iris.base_logic.lib Require Export gen_heap proph_map gen_inv_heap.
 From iris.program_logic Require Export weakestpre total_weakestpre.
 From iris.program_logic Require Import ectx_lifting total_ectx_lifting.
-From program_logic Require Import weakest_precondition basic_reasoning_rules.
-From language Require Export eff_lang.
+From hazel.program_logic Require Import weakest_precondition basic_reasoning_rules.
+From hazel.language Require Export eff_lang.
 
 Set Default Proof Using "Type".
 
@@ -41,9 +41,9 @@ Set Default Proof Using "Type".
 (* This type class formalizes the assumptions
    on the global list of cameras [Σ]. *)
 Class heapGpreS Σ := {
-  heap_GpreS_iris :> invGpreS Σ;
-  heap_GpreS_heap :> gen_heapGpreS loc val Σ;
-  heap_GpreS_inv_heap :> inv_heapGpreS loc val Σ;
+  heap_GpreS_iris :: invGpreS Σ;
+  heap_GpreS_heap :: gen_heapGpreS loc val Σ;
+  heap_GpreS_inv_heap :: inv_heapGpreS loc val Σ;
 }.
 
 (* We provide an explicit instance of such a list [Σ]
@@ -59,8 +59,8 @@ Proof. solve_inG. Qed.
    and other ghost cells related to invariants. *)
 Class heapGS Σ := HeapGS {
   heapG_invG : invGS Σ;
-  heapG_gen_heapG :> gen_heapGS loc val Σ;
-  heapG_inv_heapG :> inv_heapGS loc val Σ;
+  heapG_gen_heapG :: gen_heapGS loc val Σ;
+  heapG_inv_heapG :: inv_heapGS loc val Σ;
 }.
 
 
@@ -81,13 +81,13 @@ Global Instance heapG_irisG `{!heapGS Σ} : irisGS eff_lang Σ := {
 
 (* Derived notation for points-to predicates. *)
 
-Notation "l ↦{ dq } v" := (mapsto (L:=loc) (V:=val) l dq (v%V))
+Notation "l ↦{ dq } v" := (pointsto (L:=loc) (V:=val) l dq (v%V))
   (at level 20, format "l  ↦{ dq }  v") : bi_scope.
-Notation "l ↦□ v" := (mapsto (L:=loc) (V:=val) l DfracDiscarded (v%V))
+Notation "l ↦□ v" := (pointsto (L:=loc) (V:=val) l DfracDiscarded (v%V))
   (at level 20, format "l  ↦□  v") : bi_scope.
-Notation "l ↦{# q } v" := (mapsto (L:=loc) (V:=val) l (DfracOwn q) (v%V))
+Notation "l ↦{# q } v" := (pointsto (L:=loc) (V:=val) l (DfracOwn q) (v%V))
   (at level 20, format "l  ↦{# q }  v") : bi_scope.
-Notation "l ↦ v" := (mapsto (L:=loc) (V:=val) l (DfracOwn 1) (v%V))
+Notation "l ↦ v" := (pointsto (L:=loc) (V:=val) l (DfracOwn 1) (v%V))
   (at level 20, format "l  ↦  v") : bi_scope.
 
 
@@ -118,7 +118,7 @@ Section reasoning_rules.
     { by apply empty_subseteq. }
     iModIntro. iSplitR.
     - iPureIntro. rewrite /reducible //=.
-      set (l := fresh_locs (dom (gset loc) σ.(heap))).
+      set (l := Loc.fresh (dom σ.(heap))).
       exists [], #l, (heap_upd <[l:=v]> σ), []. simpl.
       apply (Ectx_prim_step _ _ _ _ [] (ref v)%E (#l)); try done.
       by apply alloc_fresh.
diff --git a/theories/program_logic/tactics.v b/theories/program_logic/tactics.v
index 0058172..22c9b52 100644
--- a/theories/program_logic/tactics.v
+++ b/theories/program_logic/tactics.v
@@ -12,8 +12,8 @@
 *)
 
 From iris.proofmode Require Import base tactics classes.
-From language Require Import eff_lang.
-From program_logic Require Export weakest_precondition basic_reasoning_rules.
+From hazel.language Require Import eff_lang.
+From hazel.program_logic Require Export weakest_precondition basic_reasoning_rules.
 
 (* ========================================================================== *)
 (** Tactics. *)
diff --git a/theories/program_logic/weakest_precondition.v b/theories/program_logic/weakest_precondition.v
index 61ddf52..567bed6 100644
--- a/theories/program_logic/weakest_precondition.v
+++ b/theories/program_logic/weakest_precondition.v
@@ -8,8 +8,8 @@
 
 From iris.proofmode Require Import base tactics classes.
 From iris.program_logic Require Import weakestpre.
-From language Require Export eff_lang.
-From program_logic Require Export protocols.
+From hazel.language Require Export eff_lang.
+From hazel.program_logic Require Export protocols.
 
 
 (* ========================================================================== *)
diff --git a/theories/program_logic_ext/named_effects.v b/theories/program_logic_ext/named_effects.v
deleted file mode 100644
index e69de29..0000000
-- 
2.47.0

