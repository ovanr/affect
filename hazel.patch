diff --git a/.gitignore b/.gitignore
index df00fd7..cc2f56c 100644
--- a/.gitignore
+++ b/.gitignore
@@ -13,3 +13,4 @@ _opam
 build-dep
 .coq-native/
 _build
+.Makefile.coq.d
diff --git a/_CoqProject b/_CoqProject
index 45b4b8f..58d3292 100644
--- a/_CoqProject
+++ b/_CoqProject
@@ -1,8 +1,7 @@
--Q theories/lib               lib
--Q theories/language          language
--Q theories/program_logic     program_logic
--Q theories/program_logic_ext program_logic_ext
--Q theories/case_studies      case_studies
+-Q theories/lib               hazel.lib
+-Q theories/language          hazel.language
+-Q theories/program_logic     hazel.program_logic
+-Q theories/case_studies      hazel.case_studies
 
 -arg -w -arg -convert_concl_no_check
 
@@ -26,8 +25,6 @@ theories/program_logic/deep_handler_reasoning.v
 theories/program_logic/reasoning_rules.v
 theories/program_logic/adequacy.v
 
-theories/program_logic_ext/named_effects.v
-
 theories/case_studies/list_lib.v
 theories/case_studies/queue_lib.v
 theories/case_studies/map_lib.v
@@ -35,10 +32,9 @@ theories/case_studies/iteration.v
 theories/case_studies/callcc.v
 theories/case_studies/control_inversion.v
 theories/case_studies/sat.v
-theories/case_studies/shallow_as_deep.v
+# theories/case_studies/shallow_as_deep.v
 theories/case_studies/exceptions.v
 theories/case_studies/state.v
 theories/case_studies/shift_reset.v
 theories/case_studies/asynchronous_computation.v
 theories/case_studies/automatic_differentiation.v
-theories/case_studies/ml_references.v
diff --git a/opam b/opam
index 4e3a2c2..1ca1d9d 100644
--- a/opam
+++ b/opam
@@ -1,5 +1,6 @@
 name: "coq-hazel"
 synopsis: "A separation logic for effect handlers"
+version: "1.2"
 opam-version: "2.0"
 maintainer: "Anonymous"
 bug-reports: "Anonymous"
@@ -10,6 +11,6 @@ build: [make "-j%{jobs}%"]
 install: [make "install"]
 remove: [ "sh" "-c" "rm -rf '%{lib}%/coq/user-contrib/hazel" ]
 depends: [
-  "coq" { (= "8.13.0") }
-  "coq-iris-heap-lang" { (= "dev.2022-01-15.0.52c80aad") }
+  "coq" { (= "8.18.0") }
+  "coq-iris-heap-lang" { (= "dev.2023-10-24.0.8043d14b") }
 ]
diff --git a/theories/case_studies/asynchronous_computation.v b/theories/case_studies/asynchronous_computation.v
index 9fec708..4e71cfa 100644
--- a/theories/case_studies/asynchronous_computation.v
+++ b/theories/case_studies/asynchronous_computation.v
@@ -22,8 +22,8 @@
 From iris.proofmode Require Import base tactics classes.
 From iris.algebra Require Import excl_auth gset gmap agree.
 From iris.base_logic.lib Require Import iprop wsat invariants.
-From program_logic Require Import reasoning_rules.
-From case_studies Require Import list_lib queue_lib.
+From hazel.program_logic Require Import reasoning_rules.
+From hazel.case_studies Require Import list_lib queue_lib.
 
 
 (* ========================================================================== *)
@@ -145,9 +145,9 @@ End specification.
 
 (* The assumption that certain cameras are available. *)
 Class promiseGpreS Σ := {
-  promise_mapG :> inG Σ
+  promise_mapG :: inG Σ
     (authR (gmapUR (loc * gname) (agreeR (laterO (val -d> (iPropO Σ))))));
-  torchG :> inG Σ (exclR unitO);
+  torchG :: inG Σ (exclR unitO);
 }.
 
 (* A concrete instance of [Σ] for which the assumption [promisesGS Σ] holds. *)
@@ -162,7 +162,7 @@ Instance subG_promiseΣ {Σ} : subG promiseΣ Σ → promiseGpreS Σ.
 Proof. solve_inG. Qed.
 
 Class promiseGS Σ := {
-  promise_inG :> promiseGpreS Σ;
+  promise_inG :: promiseGpreS Σ;
   promise_name : gname;
 }.
 
@@ -318,7 +318,7 @@ Section predicates.
     Proof. by iMod (own_alloc (Excl tt)) as (γ) "Htorch"; last iExists γ. Qed.
 
     Lemma claim_uniqueness γ : (torch γ ∗ torch γ) -∗ False.
-    Proof. by rewrite /torch -own_op own_valid excl_validI. Qed.
+    Proof. rewrite /torch -own_op own_valid excl_validI. iIntros "$". Qed.
 
   End torch.
 
diff --git a/theories/case_studies/automatic_differentiation.v b/theories/case_studies/automatic_differentiation.v
index 9fbd695..a5906c2 100644
--- a/theories/case_studies/automatic_differentiation.v
+++ b/theories/case_studies/automatic_differentiation.v
@@ -2,7 +2,7 @@
 
 From iris.algebra Require Import gmap_view.
 From iris.proofmode Require Import base tactics classes.
-From program_logic Require Import reasoning_rules.
+From hazel.program_logic Require Import reasoning_rules.
 
 Set Default Proof Using "Type".
 
@@ -204,9 +204,9 @@ Class RingSig (R : Set) := {
 }.
 
 Class IsRing (R : Set) {RS : RingSig R} := {
-  r_eq_equiv :> Equivalence r_eq;
-  r_add_ext  :> Proper (r_eq ==> r_eq ==> r_eq) r_add;
-  r_mul_ext  :> Proper (r_eq ==> r_eq ==> r_eq) r_mul;
+  r_eq_equiv :: Equivalence r_eq;
+  r_add_ext  :: Proper (r_eq ==> r_eq ==> r_eq) r_add;
+  r_mul_ext  :: Proper (r_eq ==> r_eq ==> r_eq) r_mul;
 
   is_semi_ring : semi_ring_theory r_zero r_one r_add r_mul r_eq
 }.
@@ -1017,7 +1017,7 @@ Section camera.
   Canonical Structure nodeO := leibnizO node.
 
   Class cgraphG Σ := {
-    cgraph_mapG :> inG Σ (gmap_viewR val nodeO);
+    cgraph_mapG :: inG Σ (gmap_viewR val nodeO);
   }.
 
   Definition cgraphΣ := #[
diff --git a/theories/case_studies/callcc.v b/theories/case_studies/callcc.v
index ed61aa5..5ccda67 100644
--- a/theories/case_studies/callcc.v
+++ b/theories/case_studies/callcc.v
@@ -5,8 +5,8 @@
 From iris.proofmode Require Import base tactics classes.
 From iris.base_logic.lib Require Import iprop.
 From iris.program_logic Require Import weakestpre.
-From language Require Import eff_lang.
-From program_logic Require Import reasoning_rules.
+From hazel.language Require Import eff_lang.
+From hazel.program_logic Require Import reasoning_rules.
 
 
 (* ========================================================================== *)
diff --git a/theories/case_studies/control_inversion.v b/theories/case_studies/control_inversion.v
index 9bc4c3c..8dd8dd6 100644
--- a/theories/case_studies/control_inversion.v
+++ b/theories/case_studies/control_inversion.v
@@ -27,9 +27,9 @@
 From stdpp Require Import list.
 From iris.proofmode Require Import base tactics classes.
 From iris.algebra Require Import excl_auth.
-From language Require Import eff_lang.
-From program_logic Require Import reasoning_rules.
-From case_studies Require Import iteration callcc.
+From hazel.language Require Import eff_lang.
+From hazel.program_logic Require Import reasoning_rules.
+From hazel.case_studies Require Import iteration callcc.
 
 
 (* ========================================================================== *)
diff --git a/theories/case_studies/exceptions.v b/theories/case_studies/exceptions.v
index e98c9ad..6e8993e 100644
--- a/theories/case_studies/exceptions.v
+++ b/theories/case_studies/exceptions.v
@@ -5,7 +5,7 @@
    exceptions. *)
 
 From iris.proofmode Require Import base tactics classes.
-From program_logic Require Import reasoning_rules.
+From hazel.program_logic Require Import reasoning_rules.
 
 
 (* ========================================================================== *)
@@ -55,7 +55,7 @@ Lemma ewp_exn_try_with `{!heapGS Σ} E Φ Φ' (e1 : expr) (e2 e3 : val) :
 Proof.
   iIntros "He1". iApply (ewp_try_with with "He1").
   iSplit; [by auto|iSplit]; iIntros (v k);
-  last by iIntros "HFalse"; rewrite upcl_bottom.
-  rewrite upcl_exn. iIntros "[%x [-> [He2 _]]]".
+  last by iIntros "_ HFalse"; rewrite upcl_bottom.
+  rewrite upcl_exn. iIntros "Heq (%x & [-> [He2 _]])".
   by ewp_pure_steps.
 Qed.
diff --git a/theories/case_studies/iteration.v b/theories/case_studies/iteration.v
index f824940..5577843 100644
--- a/theories/case_studies/iteration.v
+++ b/theories/case_studies/iteration.v
@@ -7,9 +7,9 @@
    iteration methods and lazy sequences. *)
 
 From iris.proofmode Require Import base tactics classes.
-From language Require Import eff_lang.
-From program_logic Require Import reasoning_rules.
-From case_studies Require Import list_lib.
+From hazel.language Require Import eff_lang.
+From hazel.program_logic Require Import reasoning_rules.
+From hazel.case_studies Require Import list_lib.
 
 Set Default Proof Using "Type".
 
@@ -25,7 +25,7 @@ Class Representable Σ (A : Type) :=
 (* A representable type [A] is persistently representable
    if its representation predicate holds persistently. *)
 Class PersRepresentable Σ A `{Representable Σ A} :=
-  pers_representable x X :> Persistent (represents x X).
+  pers_representable x X :: Persistent (represents x X).
 
 
 (* ========================================================================== *)
@@ -34,12 +34,12 @@ Class PersRepresentable Σ A `{Representable Σ A} :=
 (* We formalize a data structure as a type family [G], such that
    [G A] is representable for every repesentable type [A]. *)
 Class DataStructure Σ (G : Type → Type) :=
-  is_representable A `{Representable Σ A} :> Representable Σ (G A).
+  is_representable A `{Representable Σ A} :: Representable Σ (G A).
 
 (* A data structure [G] is persistent if [G A] is persistently
    representable for every persistently representable type [A]. *)
 Class PersStructure Σ G `{DataStructure Σ G} :=
-  is_pers_representable A `{PersRepresentable Σ A} :>
+  is_pers_representable A `{PersRepresentable Σ A} ::
     PersRepresentable Σ (G A).
 
 
diff --git a/theories/case_studies/list_lib.v b/theories/case_studies/list_lib.v
index d02f3fe..331408f 100644
--- a/theories/case_studies/list_lib.v
+++ b/theories/case_studies/list_lib.v
@@ -6,7 +6,7 @@
 
 From stdpp Require Import list.
 From iris.proofmode Require Import base tactics classes.
-From program_logic Require Import reasoning_rules.
+From hazel.program_logic Require Import reasoning_rules.
 
 
 (* ========================================================================== *)
diff --git a/theories/case_studies/map_lib.v b/theories/case_studies/map_lib.v
index e1e4c3a..0232120 100644
--- a/theories/case_studies/map_lib.v
+++ b/theories/case_studies/map_lib.v
@@ -2,7 +2,7 @@
 
 (* This file introduces a simple API exposing operations to manipulate maps. *)
 
-From program_logic Require Import reasoning_rules.
+From hazel.program_logic Require Import reasoning_rules.
 
 
 (* ========================================================================== *)
diff --git a/theories/case_studies/ml_references.v b/theories/case_studies/ml_references.v
deleted file mode 100644
index e69de29..0000000
diff --git a/theories/case_studies/queue_lib.v b/theories/case_studies/queue_lib.v
index 2be9a8b..d218f5e 100644
--- a/theories/case_studies/queue_lib.v
+++ b/theories/case_studies/queue_lib.v
@@ -5,8 +5,8 @@
 From stdpp Require Import list.
 From iris.proofmode Require Import base tactics classes.
 From iris.program_logic Require Import weakestpre.
-From program_logic Require Import reasoning_rules.
-From case_studies Require Import list_lib.
+From hazel.program_logic Require Import reasoning_rules.
+From hazel.case_studies Require Import list_lib.
 
 
 (* ========================================================================== *)
diff --git a/theories/case_studies/sat.v b/theories/case_studies/sat.v
index bab218c..5d5f78f 100644
--- a/theories/case_studies/sat.v
+++ b/theories/case_studies/sat.v
@@ -5,8 +5,8 @@
 
 From iris.proofmode Require Import base tactics classes.
 From iris.algebra Require Import excl_auth agree gset gmap agree.
-From program_logic Require Import reasoning_rules.
-From case_studies Require Import map_lib.
+From hazel.program_logic Require Import reasoning_rules.
+From hazel.case_studies Require Import map_lib.
 
 
 (* ========================================================================== *)
@@ -200,9 +200,10 @@ Proof.
   }
   (* Lit. *)
   { destruct (M !! i) as [b|] eqn:?.
-    { by rewrite (map_filter_lookup_Some_2 _ _ _ _ Heqo);
+    Search "map_filter_lookup".
+    { by rewrite (map_lookup_filter_Some_2 _ _ _ _ Heqo);
          [|rewrite elem_of_list_singleton ]. }
-    { by rewrite (map_filter_lookup_None_2 _ _ i); [|left]. }
+    { by rewrite (map_lookup_filter_None_2 _ _ i); [|left]. }
   }
 Qed.
 
@@ -235,7 +236,7 @@ Qed.
    [M'] of indices in [js] such that [eval (M ∪ M') p] is true. *)
 Lemma sat_proc_spec' p M js :
   sat_proc' p M js = true ↔
-    ∃ M', elements (dom (gset nat) M') ⊆ js ∧ eval (M ∪ M') p = Some true.
+    ∃ M', elements (dom M') ⊆ js ∧ eval (M ∪ M') p = Some true.
 Proof.
   (* Proof by induction on the list of indices [js]. *)
   revert js M. induction js as [|j js]; intro M.
@@ -251,7 +252,7 @@ Proof.
   - (* Case [j :: js]. *)
     simpl.
     have Haux: (∃ b, sat_proc' p (M ∪ {[j:=b]}) js = true) ↔
-      (∃ M', elements (dom (gset nat) M') ⊆ j :: js ∧
+      (∃ M', elements (dom M') ⊆ j :: js ∧
              eval (M ∪ M') p = Some true).
     { split; [intros [b Hsat]|intros [M' [Hdom Heval]]].
       { revert Hsat. rewrite IHjs. intros [M' [Hdom Heval]].
@@ -293,7 +294,7 @@ Proof.
     exists (filter (λ '(i, _), i ∈ indices p) M'). split.
     { intro i. rewrite elem_of_elements elem_of_dom.
       intros [b Hlkup]. revert Hlkup.
-      rewrite map_filter_lookup_Some. by intros [_ ?].
+      rewrite map_lookup_filter_Some. by intros [_ ?].
     }
     { rewrite -Heval eval_restriction (eval_restriction (M ∪ M')).
       have Haux: ∀ M', filter (λ '(i, _), i ∈ indices p) (M ∪ M') =
@@ -304,24 +305,24 @@ Proof.
         destruct (M !! i) as [b|] eqn:?; [|
         destruct (M' !! i) as [b'|] eqn:? ] |].
         { transitivity (Some b); [
-          by rewrite map_filter_lookup_Some (lookup_union_Some_l _ _ i b)|].
+          by rewrite map_lookup_filter_Some (lookup_union_Some_l _ _ i b)|].
           symmetry.
-          rewrite lookup_union_Some_raw map_filter_lookup_Some.
+          rewrite lookup_union_Some_raw map_lookup_filter_Some.
           by left.
         }
         { transitivity (Some b'); [
-          by rewrite map_filter_lookup_Some lookup_union_r|].
+          by rewrite map_lookup_filter_Some lookup_union_r|].
           symmetry. rewrite lookup_union_Some_raw. right.
-          rewrite map_filter_lookup_None map_filter_lookup_Some. by auto.
+          rewrite map_lookup_filter_None map_lookup_filter_Some. by auto.
         }
         { transitivity (@None bool); [
-          by rewrite map_filter_lookup_None lookup_union_r; [left|] |].
-          symmetry. rewrite lookup_union_None !map_filter_lookup_None.
+          by rewrite map_lookup_filter_None lookup_union_r; [left|] |].
+          symmetry. rewrite lookup_union_None !map_lookup_filter_None.
           split; by left.
         }
         { transitivity (@None bool); [
-          rewrite map_filter_lookup_None; by right|].
-          symmetry. rewrite lookup_union_None !map_filter_lookup_None.
+          rewrite map_lookup_filter_None; by right|].
+          symmetry. rewrite lookup_union_None !map_lookup_filter_None.
           split; by right.
         }
       }
@@ -458,7 +459,7 @@ End specification.
 (* Camera. *)
 
 Class satG Σ := {
-  assignmentG :> inG Σ (excl_authR (gmapO natO boolO));
+  assignmentG :: inG Σ (excl_authR (gmapO natO boolO));
 }.
 Definition satΣ := #[ GFunctor (excl_authR (gmapO natO boolO)) ].
 Instance subG_interpΣ {Σ} : subG satΣ Σ → satG Σ.
@@ -558,13 +559,13 @@ Section map_lib.
     { by iApply (map_insert_spec with "Hm"). }
     iIntros "!#" (_) "Hm". iModIntro. iExists (<[#i:=#b]> M'). iFrame.
     iPureIntro. split; intro j; [intro b'|];
-    case (nat_eq_dec i j) as [->|];
+    case (Nat.eq_dec i j) as [->|];
     try (rewrite !lookup_insert; by inversion 1).
     { rewrite !lookup_insert_ne; [apply H| |done]; intro Heq; apply n;
-      inversion Heq; by apply Z_of_nat_inj.
+      inversion Heq. by apply Znat.Nat2Z.inj.
     }
     { rewrite !lookup_insert_ne; [apply H0| |done]; intro Heq; apply n;
-      inversion Heq; by apply Z_of_nat_inj.
+      inversion Heq; by apply Znat.Nat2Z.inj.
     }
   Qed.
 
@@ -578,11 +579,12 @@ Section map_lib.
     { by iApply (map_delete_spec with "Hm"). }
     iIntros "!#" (_) "Hm". iModIntro. iExists (delete #i M'). iFrame.
     iPureIntro. split; intro j; [intro b'|];
-    case (nat_eq_dec i j) as [->|]; try (rewrite !lookup_delete; by inversion 1).
+    case (Nat.eq_dec i j) as [->|]; try (rewrite !lookup_delete; by inversion 1).
     { rewrite !lookup_delete_ne; [apply H| |done]; intro Heq; apply n;
-      inversion Heq; by apply Z_of_nat_inj.  }
+      inversion Heq; by apply Znat.Nat2Z.inj.
+    }
     { rewrite !lookup_delete_ne; [apply H0| |done]; intro Heq; apply n;
-      inversion Heq; by apply Z_of_nat_inj.
+      inversion Heq; by apply Znat.Nat2Z.inj.
     }
   Qed.
 
@@ -636,7 +638,7 @@ Section interp.
       iExists M, i. iFrame. iSplit; [done|].
       iIntros "!#" (b) "[%Hb HM]". unfold interp_sign. ewp_pure_steps.
       assert (M ∪ {[i:=b]} = <[i:=b]> M) as Haux.
-      { apply map_eq. intro j. case (nat_eq_dec i j) as [->|].
+      { apply map_eq. intro j. case (Nat.eq_dec i j) as [->|].
         { by rewrite lookup_insert -Hb lookup_union lookup_singleton;
           case (M !! j). }
         { rewrite lookup_insert_ne; [|done].
diff --git a/theories/case_studies/shallow_as_deep.v b/theories/case_studies/shallow_as_deep.v
index 633478a..7139bdf 100644
--- a/theories/case_studies/shallow_as_deep.v
+++ b/theories/case_studies/shallow_as_deep.v
@@ -11,7 +11,7 @@
    to make an assumption: effects are either all one-shot or all multi-shot. *)
 
 From iris.proofmode Require Import base tactics classes.
-From program_logic Require Import reasoning_rules.
+From hazel.program_logic Require Import reasoning_rules.
 
 
 (* ========================================================================== *)
diff --git a/theories/case_studies/shift_reset.v b/theories/case_studies/shift_reset.v
index 5a50ddc..e5530c4 100644
--- a/theories/case_studies/shift_reset.v
+++ b/theories/case_studies/shift_reset.v
@@ -4,7 +4,7 @@
    [shift0/reset0] and [shift/reset]. *)
 
 From iris.proofmode Require Import base tactics classes.
-From program_logic Require Import reasoning_rules.
+From hazel.program_logic Require Import reasoning_rules.
 
 
 (* ========================================================================== *)
diff --git a/theories/case_studies/state.v b/theories/case_studies/state.v
index eed15e4..86c0100 100644
--- a/theories/case_studies/state.v
+++ b/theories/case_studies/state.v
@@ -4,7 +4,7 @@
 
 From iris.proofmode Require Import base tactics classes.
 From iris.algebra Require Import excl_auth.
-From program_logic Require Import reasoning_rules.
+From hazel.program_logic Require Import reasoning_rules.
 
 
 (* ========================================================================== *)
diff --git a/theories/language/eff_lang.v b/theories/language/eff_lang.v
index 950f743..4dd9cb6 100644
--- a/theories/language/eff_lang.v
+++ b/theories/language/eff_lang.v
@@ -1,5 +1,5 @@
 (* eff_lang.v *)
 
-From language Require Export syntax notation semantics
-                             neutral_contexts properties
-                             iris_language.
+From hazel.language Require Export syntax notation semantics
+                                   neutral_contexts properties
+                                   iris_language.
diff --git a/theories/language/iris_language.v b/theories/language/iris_language.v
index eb055d1..1211692 100644
--- a/theories/language/iris_language.v
+++ b/theories/language/iris_language.v
@@ -12,7 +12,7 @@
 *)
 
 From iris.program_logic Require Import language.
-From language Require Import syntax semantics neutral_contexts.
+From hazel.language Require Import syntax semantics neutral_contexts.
 
 
 (* ========================================================================== *)
@@ -157,8 +157,13 @@ Proof.
     rewrite lookup_insert in H4. done.
   - split; [|done]. destruct σ1 as [σ1].
     by rewrite /heap_upd /= insert_insert.
-  - unfold heap_upd in H10. simpl in H10.
-    rewrite lookup_insert in H10. done.
+  - rewrite !H7. rewrite lookup_insert in H8.
+    simplify_eq. rewrite - H7 in H0.
+    rewrite lookup_insert in H0. by simplify_eq.
+  - unfold heap_upd. simpl. rewrite insert_insert. 
+    split; first done. rewrite - H7 in H0.
+    by simplify_eq. 
+  - rewrite lookup_insert in H10. discriminate.
 Qed.
 
 Lemma val_not_pure v e : ¬ pure_prim_step (Val v) e.
@@ -430,7 +435,7 @@ Qed.
 (* Inversion principle for reduction of a one-shot continuation. *)
 Lemma prim_step_inv_Cont k l (w : val) σ e' σ' :
   prim_step (App (Val $ (ContV k l)) (Val w)) σ e' σ' →
-    e' = fill k (Val w) ∧ σ' = heap_upd <[l := LitV $ LitBool $ true]> σ.
+    e' = fill k (Val w) ∧ σ' = heap_upd <[l := Some (LitV $ LitBool $ true)]> σ.
 Proof.
   intros Hstep. inversion Hstep.
   repeat ((destruct k0 as [|f k0]; [|destruct f; try naive_solver];
@@ -442,7 +447,7 @@ Qed.
 Lemma prim_step_inv_TryWithOSEff (v : val) k h r σ e' σ' :
   prim_step (TryWith (Eff OS v k) h r) σ e' σ' →
     ∃ l, σ.(heap) !! l = None ∧
-         σ' = heap_upd <[l := LitV $ LitBool $ false]> σ ∧
+         σ' = heap_upd <[l := Some (LitV $ LitBool $ false)]> σ ∧
          e' = (App (App h (Val v)) (Val $ ContV k l)).
 Proof.
   intros Hstep. inversion Hstep.
diff --git a/theories/language/neutral_contexts.v b/theories/language/neutral_contexts.v
index 0d2b2ff..9c3b995 100644
--- a/theories/language/neutral_contexts.v
+++ b/theories/language/neutral_contexts.v
@@ -7,7 +7,7 @@
    [program_logic/weakest_precondition.v].
 *)
 
-From language Require Import syntax semantics.
+From hazel.language Require Import syntax semantics.
 
 (* ========================================================================== *)
 (** * Definition of Neutral Contexts. *)
@@ -68,6 +68,12 @@ Instance StoreLCtx_neutral v2 : NeutralFrame (StoreLCtx v2).
 Proof. constructor => v k σ. by apply StoreLEffS. Qed.
 Instance StoreRCtx_neutral e1 : NeutralFrame (StoreRCtx e1).
 Proof. constructor => v k σ. by apply StoreREffS. Qed.
+Instance ReplaceLCtx_neutral v2 : NeutralFrame (ReplaceLCtx v2).
+Proof. constructor => v k σ. by apply ReplaceLEffS. Qed.
+Instance ReplaceRCtx_neutral e1 : NeutralFrame (ReplaceRCtx e1).
+Proof. constructor => v k σ. by apply ReplaceREffS. Qed.
+Instance FreeCtx_neutral : NeutralFrame FreeCtx.
+Proof. constructor => v k σ. by apply FreeEffS. Qed.
 
 Lemma TryWithCtx_not_neutral e2 e3 : ¬ NeutralFrame (TryWithCtx e2 e3).
 Proof.
diff --git a/theories/language/notation.v b/theories/language/notation.v
index b224bed..66c9fdc 100644
--- a/theories/language/notation.v
+++ b/theories/language/notation.v
@@ -5,7 +5,7 @@
 *)
 
 From iris.program_logic Require Import language.
-From language Require Export syntax.
+From hazel.language Require Export syntax.
 
 Set Default Proof Using "Type".
 
@@ -103,6 +103,8 @@ Notation "~ e" := (UnOp NegOp e%E) (at level 75, right associativity) : expr_sco
 (* The unicode ← is already part of the notation "_ ← _; _" for bind. *)
 Notation "e1 <- e2" := (Store e1%E e2%E) (at level 80) : expr_scope.
 
+Notation "e1 <!- e2" := (Replace e1%E e2%E) (at level 80) : expr_scope.
+
 (* The breaking point '/  ' makes sure that the body of the rec is indented
 by two spaces in case the whole rec does not fit on a single line. *)
 Notation "'rec:' f x := e" := (Rec f%binder x%binder e%E)
diff --git a/theories/language/properties.v b/theories/language/properties.v
index 6ef98a9..a779699 100644
--- a/theories/language/properties.v
+++ b/theories/language/properties.v
@@ -3,8 +3,8 @@
 (* This file collects general facts about [eff_lang] and its
    related definitions. *)
 
-From lib Require Export lib.
-From language Require Import syntax.
+From hazel.lib Require Export lib.
+From hazel.language Require Import syntax.
 
 (* ========================================================================== *)
 (** * Markers. *)
diff --git a/theories/language/semantics.v b/theories/language/semantics.v
index df0a138..9450df9 100644
--- a/theories/language/semantics.v
+++ b/theories/language/semantics.v
@@ -31,7 +31,7 @@
 
 *)
 
-From language Require Import syntax.
+From hazel.language Require Import syntax.
 
 (* ========================================================================== *)
 (** * Preliminary Definitions. *)
@@ -79,6 +79,12 @@ Definition fill_frame (f : frame) (e : expr) : expr :=
       Store e (Val v2)
   | StoreRCtx e1 =>
       Store e1 e
+  | ReplaceLCtx v2 =>
+      Replace e (Val v2)
+  | ReplaceRCtx e1 =>
+      Replace e1 e
+  | FreeCtx =>
+      Free e
   end.
 
 
@@ -187,6 +193,10 @@ Fixpoint subst (x : string) (v : val) (e : expr) : expr :=
       Load (subst x v e)
   | Store e1 e2 =>
       Store (subst x v e1) (subst x v e2)
+  | Replace e1 e2 =>
+      Replace (subst x v e1) (subst x v e2)
+  | Free e =>
+      Free (subst x v e)
   end.
 
 Definition subst' (mx : binder) (v : val) : expr → expr :=
@@ -205,6 +215,10 @@ Definition un_op_eval (op : un_op) (v : val) : option val :=
       Some $ LitV $ LitInt (Z.lnot n)
   | MinusUnOp, LitV (LitInt n) =>
       Some $ LitV $ LitInt (- n)
+  | IsContOS, (ContV _ _) =>
+      Some $ LitV $ LitBool true
+  | IsContOS, (KontV _) =>
+      Some $ LitV $ LitBool false
   | _, _ =>
       None
   end.
@@ -276,7 +290,7 @@ Definition bin_op_eval (op : bin_op) (v1 v2 : val) : option val :=
     end.
 
 (* Heap update. *)
-Definition heap_upd (f : gmap loc val → gmap loc val) : state → state :=
+Definition heap_upd (f : gmap loc (option val) → gmap loc (option val)) : state → state :=
   λ σ,  {| heap := f σ.(heap) |}.
 Arguments heap_upd _ !_ /.
 
@@ -300,10 +314,10 @@ Inductive head_step : expr → state → expr → state → Prop :=
        head_step (App (Val $ RecV f x e1) (Val v2)) σ e' σ
   (* Invoking a one-shot continuation. *)
   | ContS k l w e' σ :
-     σ.(heap) !! l = Some (LitV $ LitBool false) →
+     σ.(heap) !! l = Some (Some (LitV $ LitBool false)) →
        e' = fill k (Val w) →
          head_step (App (Val (ContV k l)) (Val w))            σ
-                    e' (heap_upd <[l:=(LitV $ LitBool true)]> σ)
+                    e' (heap_upd <[l:=Some (LitV $ LitBool true)]> σ)
   (* Invoking a multi-shot continuation. *)
   | KontS k w e' σ :
      e' = fill k (Val w) →
@@ -336,16 +350,26 @@ Inductive head_step : expr → state → expr → state → Prop :=
   | AllocS v σ l :
      σ.(heap) !! l = None →
        head_step (Alloc (Val v))                            σ
-                 (Val $ LitV $ LitLoc l) (heap_upd <[l:=v]> σ)
+                 (Val $ LitV $ LitLoc l) (heap_upd <[l:=Some v]> σ)
   (* Load. *)
   | LoadS l v σ :
-     σ.(heap) !! l = Some v →
+     σ.(heap) !! l = Some (Some v) →
        head_step (Load (Val $ LitV $ LitLoc l)) σ (of_val v) σ
   (* Store. *)
-  | StoreS l v σ :
-     is_Some (σ.(heap) !! l) →
+  | StoreS l v w σ :
+     σ.(heap) !! l = Some (Some w) →
        head_step (Store (Val $ LitV $ LitLoc l) (Val v)) σ
-                 (Val $ LitV LitUnit) (heap_upd <[l:=v]> σ)
+                 (Val $ LitV LitUnit) (heap_upd <[l:=Some v]> σ)
+  (* Replace. *)
+  | ReplaceS l w v σ :
+     σ.(heap) !! l = Some (Some w) →
+       head_step (Replace (Val $ LitV $ LitLoc l) (Val v)) σ
+                 (of_val w) (heap_upd <[l:=Some v]> σ)
+  (* Free. *)
+  | FreeS v σ l :
+     σ.(heap) !! l = Some (Some v) →
+       head_step (Free (Val $ LitV $ LitLoc l)) σ
+                 (of_val v) (heap_upd <[l:=None]> σ)
   (* Do. *)
   | DoS m v σ :
      head_step (Do m (Val v)) σ (Eff m v []) σ
@@ -354,7 +378,7 @@ Inductive head_step : expr → state → expr → state → Prop :=
      σ.(heap) !! l = None →
        head_step (TryWith (Eff OS v k) e2 e3)            σ
                  (App (App e2 (Val v)) (Val (ContV k l)))
-                 (heap_upd <[l:=(LitV $ LitBool false)]> σ)
+                 (heap_upd <[l:=Some (LitV $ LitBool false)]> σ)
   (* TryWithMS. *)
   | TryWithMSEffS v k e2 e3 σ :
      head_step (TryWith (Eff MS v k) e2 e3)           σ
@@ -430,6 +454,18 @@ Inductive head_step : expr → state → expr → state → Prop :=
   | StoreREffS m e1 v2 k σ :
      head_step (Store e1 (Eff m v2 k))          σ
                (Eff m v2 ((StoreRCtx e1) :: k)) σ
+  (* ReplaceLCtx. *)
+  | ReplaceLEffS m v1 k v2 σ :
+     head_step (Replace (Eff m v1 k) (Val v2))    σ
+               (Eff m v1 ((ReplaceLCtx v2) :: k)) σ
+  (* ReplaceRCtx. *)
+  | ReplaceREffS m e1 v2 k σ :
+     head_step (Replace e1 (Eff m v2 k))          σ
+               (Eff m v2 ((ReplaceRCtx e1) :: k)) σ
+  (* AllocCtx. *)
+  | FreeEffS m v k σ :
+     head_step (Free (Eff m v k))       σ
+               (Eff m v (FreeCtx :: k)) σ
   (* EffCtx. *)
   | DoEffS m m' v k σ :
      head_step (Do m (Eff m' v k))         σ
@@ -499,29 +535,29 @@ Proof. destruct 1; eauto. Qed.
 
 (* There is always a fresh location to be used by [Alloc v]. *)
 Lemma alloc_fresh v σ :
-  let l := fresh_locs (dom (gset loc) σ.(heap)) in
+  let l := Loc.fresh (dom σ.(heap)) in
   head_step (Alloc (Val v))                            σ
-            (Val $ LitV $ LitLoc l) (heap_upd <[l:=v]> σ).
+            (Val $ LitV $ LitLoc l) (heap_upd <[l:=Some v]> σ).
 Proof.
   intros.
   apply AllocS.
   intros. apply (not_elem_of_dom (D := gset loc)).
-  specialize (fresh_locs_fresh (dom _ (heap σ)) 0).
-  rewrite loc_add_0. naive_solver.
+  specialize (Loc.fresh_fresh (dom (heap σ)) 0).
+  rewrite Loc.add_0. naive_solver.
 Qed.
 
 (* There is always a fresh location to be used in the
    creation of a new one-shot continuation. *)
 Lemma try_with_fresh h r v k σ :
- let l := fresh_locs (dom (gset loc) σ.(heap)) in
+ let l := Loc.fresh (dom σ.(heap)) in
  head_step (TryWith (Eff OS v k) h r)           σ
            (App (App h (Val v)) (Val (ContV k l)))
-           (heap_upd <[l:=LitV $ LitBool false]> σ).
+           (heap_upd <[l:=Some (LitV $ LitBool false)]> σ).
 Proof.
   intros. apply TryWithOSEffS.
   intros. apply (not_elem_of_dom (D := gset loc)).
-  specialize (fresh_locs_fresh (dom _ (heap σ)) 0).
-  rewrite loc_add_0. naive_solver.
+  specialize (Loc.fresh_fresh (dom (heap σ)) 0).
+  rewrite Loc.add_0. naive_solver.
 Qed.
 
 Lemma Ectxi_prim_step_inv f e e₂ σ₁ σ₂ :
diff --git a/theories/language/syntax.v b/theories/language/syntax.v
index 3d0b3e7..e57066c 100644
--- a/theories/language/syntax.v
+++ b/theories/language/syntax.v
@@ -32,8 +32,10 @@ From iris.heap_lang Require Export locations. (* Domain of locations. *)
 
 Set Default Proof Using "Type".
 
+Declare Scope expr_scope.
 Delimit Scope expr_scope with E.
-Delimit Scope val_scope  with V.
+Declare Scope val_scope.
+Delimit Scope val_scope with V.
 
 
 (* ========================================================================== *)
@@ -49,12 +51,14 @@ Section eff_lang.
     | LitInt (n : Z)
     | LitBool (b : bool)
     | LitUnit
-    | LitLoc (l : loc).
+    | LitLoc (l : loc)
+    | LitStr (s : string).
 
   (* Unary operations. *)
   Inductive un_op : Set :=
     | NegOp
-    | MinusUnOp.
+    | MinusUnOp
+    | IsContOS.
 
   (* Binary operations. *)
   Inductive bin_op : Set :=
@@ -103,6 +107,8 @@ Section eff_lang.
     | Alloc (e : expr)
     | Load (e : expr)
     | Store (e1 e2 : expr)
+    | Replace (e1 e2 : expr)
+    | Free (e : expr)
 
   (* Values. *)
   with val :=
@@ -153,13 +159,16 @@ Section eff_lang.
     | AllocCtx
     | LoadCtx
     | StoreLCtx (v2 : val)
-    | StoreRCtx (e1 : expr).
+    | StoreRCtx (e1 : expr)
+    | ReplaceLCtx (v2 : val)
+    | ReplaceRCtx (e1 : expr)
+    | FreeCtx.
 
   (* Evaluation contexts. *)
   Definition ectx := list frame.
 
   (* Heaps. *)
-  Record state : Type := { heap: gmap loc val }.
+  Record state : Type := { heap: gmap loc (option val) }.
 
 End eff_lang.
 
@@ -229,6 +238,8 @@ Section induction_principle.
     (Alloc_case : ∀ e, P e → P (Alloc e))
     (Load_case : ∀ e, P e → P (Load e))
     (Store_case : ∀ e1 e2, P e1 → P e2 → P (Store e1 e2))
+    (Replace_case : ∀ e1 e2, P e1 → P e2 → P (Replace e1 e2))
+    (Free_case : ∀ e, P e → P (Free e))
 
   (* Values. *)
     (* Base values. *)
@@ -273,6 +284,9 @@ Section induction_principle.
     (LoadCtx_case : R LoadCtx)
     (StoreLCtx_case : ∀ v2, Q v2 → R (StoreLCtx v2))
     (StoreRCtx_case : ∀ e1, P e1 → R (StoreRCtx e1))
+    (ReplaceLCtx_case : ∀ v2, Q v2 → R (ReplaceLCtx v2))
+    (ReplaceRCtx_case : ∀ e1, P e1 → R (ReplaceRCtx e1))
+    (FreeCtx_case : R FreeCtx)
 
   (* Evaluation contexts. *)
     (EmptyCtx_case : S [])
@@ -326,6 +340,10 @@ Section induction_principle.
         Load_case e (expr_ind e)
     | Store e1 e2 =>
         Store_case e1 e2 (expr_ind e1) (expr_ind e2)
+    | Replace e1 e2 =>
+        Replace_case e1 e2 (expr_ind e1) (expr_ind e2)
+    | Free e =>
+        Free_case e (expr_ind e)
     end.
 
   Definition val_ind_pre
@@ -401,6 +419,12 @@ Section induction_principle.
         StoreLCtx_case v2 (val_ind v2)
     | StoreRCtx e1 =>
         StoreRCtx_case e1 (expr_ind e1)
+    | ReplaceLCtx v2 =>
+        ReplaceLCtx_case v2 (val_ind v2)
+    | ReplaceRCtx e1 =>
+        ReplaceRCtx_case e1 (expr_ind e1)
+    | FreeCtx =>
+        FreeCtx_case
     end.
 
   Definition ectx_ind_pre
@@ -602,6 +626,21 @@ Section eq_decidable.
       | _ => right _
       end); congruence.
   Qed.
+  Definition eq_dec_Replace_case e1 e2
+    (He1 : P e1) (He2 : P e2) : P (Replace e1 e2).
+    refine (λ e',
+      match e' with
+      | Replace e1' e2' => cast_if_and (He1 e1') (He2 e2')
+      | _ => right _
+      end); congruence.
+  Qed.
+  Definition eq_dec_Free_case e (He : P e) : P (Free e).
+    refine (λ e',
+      match e' with
+      | Free e' => cast_if (He e')
+      | _ => right _
+      end); congruence.
+  Qed.
 
   (* Values. *)
   Definition eq_dec_LitV_case l : Q (LitV l).
@@ -759,6 +798,22 @@ Section eq_decidable.
       | _ => right _
       end); congruence.
   Qed.
+  Definition eq_dec_ReplaceLCtx_case v2 (Hv2 : Q v2) : R (ReplaceLCtx v2).
+    refine (λ f',
+      match f' with
+      | ReplaceLCtx v2' => cast_if (Hv2 v2')
+      | _ => right _
+      end); congruence.
+  Qed.
+  Definition eq_dec_ReplaceRCtx_case e1 (He1 : P e1) : R (ReplaceRCtx e1).
+    refine (λ f',
+      match f' with
+      | ReplaceRCtx e1' => cast_if (He1 e1')
+      | _ => right _
+      end); congruence.
+  Qed.
+  Definition eq_dec_FreeCtx_case : R FreeCtx.
+    by refine (λ f', match f' with FreeCtx => left _ | _ => right _ end). Qed.
 
   (* Evaluation contexts. *)
   Definition eq_dec_EmptyCtx_case : S [].
@@ -792,6 +847,8 @@ Section eq_decidable.
       eq_dec_Alloc_case
       eq_dec_Load_case
       eq_dec_Store_case
+      eq_dec_Replace_case
+      eq_dec_Free_case
       eq_dec_LitV_case
       eq_dec_RecV_case
       eq_dec_PairV_case
@@ -818,6 +875,9 @@ Section eq_decidable.
       eq_dec_LoadCtx_case
       eq_dec_StoreLCtx_case
       eq_dec_StoreRCtx_case
+      eq_dec_ReplaceLCtx_case
+      eq_dec_ReplaceRCtx_case
+      eq_dec_FreeCtx_case
       eq_dec_EmptyCtx_case
       eq_dec_ConsCtx_case.
 
@@ -842,6 +902,8 @@ Section eq_decidable.
       eq_dec_Alloc_case
       eq_dec_Load_case
       eq_dec_Store_case
+      eq_dec_Replace_case
+      eq_dec_Free_case
       eq_dec_LitV_case
       eq_dec_RecV_case
       eq_dec_PairV_case
@@ -868,6 +930,9 @@ Section eq_decidable.
       eq_dec_LoadCtx_case
       eq_dec_StoreLCtx_case
       eq_dec_StoreRCtx_case
+      eq_dec_ReplaceLCtx_case
+      eq_dec_ReplaceRCtx_case
+      eq_dec_FreeCtx_case
       eq_dec_EmptyCtx_case
       eq_dec_ConsCtx_case.
 
@@ -892,6 +957,8 @@ Section eq_decidable.
       eq_dec_Alloc_case
       eq_dec_Load_case
       eq_dec_Store_case
+      eq_dec_Replace_case
+      eq_dec_Free_case
       eq_dec_LitV_case
       eq_dec_RecV_case
       eq_dec_PairV_case
@@ -918,6 +985,9 @@ Section eq_decidable.
       eq_dec_LoadCtx_case
       eq_dec_StoreLCtx_case
       eq_dec_StoreRCtx_case
+      eq_dec_ReplaceLCtx_case
+      eq_dec_ReplaceRCtx_case
+      eq_dec_FreeCtx_case
       eq_dec_EmptyCtx_case
       eq_dec_ConsCtx_case.
 
@@ -942,6 +1012,8 @@ Section eq_decidable.
       eq_dec_Alloc_case
       eq_dec_Load_case
       eq_dec_Store_case
+      eq_dec_Replace_case
+      eq_dec_Free_case
       eq_dec_LitV_case
       eq_dec_RecV_case
       eq_dec_PairV_case
@@ -968,6 +1040,9 @@ Section eq_decidable.
       eq_dec_LoadCtx_case
       eq_dec_StoreLCtx_case
       eq_dec_StoreRCtx_case
+      eq_dec_ReplaceLCtx_case
+      eq_dec_ReplaceRCtx_case
+      eq_dec_FreeCtx_case
       eq_dec_EmptyCtx_case
       eq_dec_ConsCtx_case.
 
@@ -1004,19 +1079,21 @@ Qed.
 Instance base_lit_countable : Countable base_lit.
 Proof.
   refine (inj_countable'
-    ((* Encoding: base_lit → (nat + bool) + (unit + loc). *) λ l,
+    ((* Encoding: base_lit → (nat + bool) + (unit + (loc + string)). *) λ l,
        match l with
        | LitInt n  => inl (inl n)
        | LitBool b => inl (inr b)
        | LitUnit   => inr (inl ())
-       | LitLoc l  => inr (inr l)
+       | LitLoc l  => inr (inr (inl l))
+       | LitStr s  => inr (inr (inr s))
        end)
     ((* Decoding. *) λ l,
        match l with
        | inl (inl n)  => LitInt n
        | inl (inr b)  => LitBool b
        | inr (inl ()) => LitUnit
-       | inr (inr l)  => LitLoc l
+       | inr (inr (inl l))  => LitLoc l
+       | inr (inr (inr s))  => LitStr s
        end) _);
   by intros [].
 Qed.
@@ -1024,9 +1101,9 @@ Instance un_op_finite : Countable un_op.
 Proof.
   refine (inj_countable'
     ((* Encoding. *) λ op,
-       match op with NegOp => 0 | MinusUnOp => 1 end)
+       match op with NegOp => 0 | MinusUnOp => 1 | IsContOS => 2 end)
     ((* Decoding. *) λ n,
-       match n with 0 => NegOp | _ => MinusUnOp end) _);
+       match n with 0 => NegOp | 1 => MinusUnOp | _ => IsContOS end) _);
   by intros [].
 Qed.
 Instance bin_op_countable : Countable bin_op.
@@ -1130,6 +1207,10 @@ Section countable.
     GenNode 17 [ge].
   Definition encode_Store (e1 e2 : expr) (ge1 ge2 : gtree) : gtree :=
     GenNode 18 [ge1; ge2].
+  Definition encode_Replace (e1 e2 : expr) (ge1 ge2 : gtree) : gtree :=
+    GenNode 19 [ge1; ge2].
+  Definition encode_Free (e : expr) (ge : gtree) : gtree :=
+    GenNode 20 [ge].
 
   (* Values. *)
   Definition encode_LitV l : gtree :=
@@ -1186,6 +1267,12 @@ Section countable.
     GenNode 17 [gv2].
   Definition encode_StoreRCtx (e1 : expr) (ge1 : gtree) : gtree :=
     GenNode 18 [ge1].
+  Definition encode_ReplaceLCtx (v2 : val) (gv2 : gtree) : gtree :=
+    GenNode 19 [gv2].
+  Definition encode_ReplaceRCtx (e1 : expr) (ge1 : gtree) : gtree :=
+    GenNode 20 [ge1].
+  Definition encode_FreeCtx : gtree :=
+    GenNode 21 [].
 
   (* Evaluation contexts. *)
   Definition encode_EmptyCtx : gtree :=
@@ -1214,6 +1301,8 @@ Section countable.
       encode_Alloc
       encode_Load
       encode_Store
+      encode_Replace
+      encode_Free
       encode_LitV
       encode_RecV
       encode_PairV
@@ -1240,6 +1329,9 @@ Section countable.
       encode_LoadCtx
       encode_StoreLCtx
       encode_StoreRCtx
+      encode_ReplaceLCtx
+      encode_ReplaceRCtx
+      encode_FreeCtx
       encode_EmptyCtx
       encode_ConsCtx.
 
@@ -1264,6 +1356,8 @@ Section countable.
       encode_Alloc
       encode_Load
       encode_Store
+      encode_Replace
+      encode_Free
       encode_LitV
       encode_RecV
       encode_PairV
@@ -1290,6 +1384,9 @@ Section countable.
       encode_LoadCtx
       encode_StoreLCtx
       encode_StoreRCtx
+      encode_ReplaceLCtx
+      encode_ReplaceRCtx
+      encode_FreeCtx
       encode_EmptyCtx
       encode_ConsCtx.
 
@@ -1314,6 +1411,8 @@ Section countable.
       encode_Alloc
       encode_Load
       encode_Store
+      encode_Replace
+      encode_Free
       encode_LitV
       encode_RecV
       encode_PairV
@@ -1340,6 +1439,9 @@ Section countable.
       encode_LoadCtx
       encode_StoreLCtx
       encode_StoreRCtx
+      encode_ReplaceLCtx
+      encode_ReplaceRCtx
+      encode_FreeCtx
       encode_EmptyCtx
       encode_ConsCtx.
 
@@ -1364,6 +1466,8 @@ Section countable.
       encode_Alloc
       encode_Load
       encode_Store
+      encode_Replace
+      encode_Free
       encode_LitV
       encode_RecV
       encode_PairV
@@ -1390,6 +1494,9 @@ Section countable.
       encode_LoadCtx
       encode_StoreLCtx
       encode_StoreRCtx
+      encode_ReplaceLCtx
+      encode_ReplaceRCtx
+      encode_FreeCtx
       encode_EmptyCtx
       encode_ConsCtx.
 
@@ -1439,6 +1546,10 @@ Section countable.
         Load (decode_expr ge)
     | GenNode 18 [ge1; ge2] =>
         Store (decode_expr ge1) (decode_expr ge2)
+    | GenNode 19 [ge1; ge2] =>
+        Replace (decode_expr ge1) (decode_expr ge2)
+    | GenNode 20 [ge] =>
+        Free (decode_expr ge)
     | _ =>
         Val $ LitV $ LitUnit
     end.
@@ -1508,6 +1619,12 @@ Section countable.
         StoreLCtx (decode_val gv2)
     | GenNode 18 [ge1] =>
         StoreRCtx (decode_expr ge1)
+    | GenNode 19 [gv2] =>
+        ReplaceLCtx (decode_val gv2)
+    | GenNode 20 [ge1] =>
+        ReplaceRCtx (decode_expr ge1)
+    | GenNode 21 [] =>
+        FreeCtx
     | _ =>
         FstCtx
     end.
diff --git a/theories/program_logic/adequacy.v b/theories/program_logic/adequacy.v
index 42a5963..8f1fdfa 100644
--- a/theories/program_logic/adequacy.v
+++ b/theories/program_logic/adequacy.v
@@ -11,7 +11,7 @@
 From iris.proofmode Require Import base tactics classes.
 From iris.base_logic.lib Require Import iprop wsat.
 From iris.program_logic Require Import weakestpre adequacy.
-From program_logic Require Import reasoning_rules.
+From hazel.program_logic Require Import reasoning_rules.
 
 
 (* ========================================================================== *)
@@ -39,11 +39,11 @@ Proof.
   - rewrite ewp_unfold /ewp_pre wp_unfold /wp_pre /= Heqo Heqo0.
     iIntros "Hewp" (σ ns k ks nt) "Hs".
     iMod ("Hewp" $! σ ns k ks nt with "Hs") as "[$ H]". iModIntro.
-    iIntros (e2 σ2 efs Hstep).
+    iIntros (e2 σ2 efs Hstep) "Hcred".
     case k   as [|??]; [|done].
     case efs as [|??]; [|done].
     simpl in Hstep.
-    iMod ("H" with "[//]") as "H". iIntros "!> !>".
+    iMod ("H" with "[//] Hcred") as "H". iIntros "!> !>".
     simpl. iMod "H". iModIntro.
     iApply (step_fupdN_wand with "[H]"); first by iApply "H".
     iIntros "H". iMod "H" as "[$ Hewp]". iModIntro.
@@ -72,7 +72,7 @@ Section adequacy.
   Proof.
     intros Hwp; eapply (wp_adequacy _ _); iIntros (??) "".
     iMod (gen_heap_init σ.(heap)) as (?) "[Hh _]".
-    iMod (inv_heap_init loc val) as (?) ">Hi".
+    iMod (inv_heap_init loc (option val)) as (?) ">Hi".
     iModIntro. iExists
       (λ σ κs, gen_heap_interp σ.(heap)),
       (λ _, True%I).
diff --git a/theories/program_logic/basic_reasoning_rules.v b/theories/program_logic/basic_reasoning_rules.v
index 8ec106b..d10a74b 100644
--- a/theories/program_logic/basic_reasoning_rules.v
+++ b/theories/program_logic/basic_reasoning_rules.v
@@ -9,7 +9,7 @@
 
 From iris.proofmode Require Import base tactics classes.
 From iris.program_logic Require Import weakestpre.
-From program_logic Require Import weakest_precondition.
+From hazel.program_logic Require Import weakest_precondition.
 
 
 (* ========================================================================== *)
@@ -46,12 +46,12 @@ Section reasoning_rules.
     iEff_car (upcl OS Ψ1) v (λ w,
       ▷ EWP fill k (Val w) @ E <| Ψ1 |> {| Ψ2 |} {{ Φ }}) -∗
     EWP of_eff OS v k @ E <| Ψ1 |> {| Ψ2 |} {{ Φ }}.
-  Proof. by rewrite ewp_eff_os_eq. Qed.
+  Proof. rewrite ewp_eff_os_eq. iIntros "$". Qed.
   Lemma ewp_eff_ms E Ψ1 Ψ2 Φ v k :
     iEff_car (upcl MS Ψ2) v (λ w,
       ▷ EWP fill k (Val w) @ E <| Ψ1 |> {| Ψ2 |} {{ Φ }}) -∗
     EWP of_eff MS v k @ E <| Ψ1 |> {| Ψ2 |} {{ Φ }}.
-  Proof. by rewrite ewp_eff_ms_eq. Qed.
+  Proof. rewrite ewp_eff_ms_eq. iIntros "$". Qed.
 
   (* Test. *)
   Goal forall A (P : A → iProp Σ) Φ (Ψ : iEff Σ) (v : val) x,
@@ -94,8 +94,8 @@ Section reasoning_rules.
       iIntros (σ₁ ns k ks nt) "Hσ".
       iMod (fupd_mask_subseteq E) as "Hclose"; first done.
       iMod ("He" with "[$]") as "[$ H]".
-      iModIntro. iIntros (e₂ σ₂ Hstep).
-      iMod ("H" with "[//]") as "H". iIntros "!> !>".
+      iModIntro. iIntros (e₂ σ₂ Hstep) "Hcred".
+      iMod ("H" with "[//] Hcred") as "H". iIntros "!> !>".
       iMod "H". iModIntro.
       iApply (step_fupdN_wand with "[H]"); first by iApply "H".
       iIntros ">($ & H)". iMod "Hclose" as "_". iModIntro.
@@ -126,8 +126,8 @@ Section reasoning_rules.
       iIntros (σ₁ ns k ks nt) "Hσ".
       iMod (fupd_mask_subseteq E) as "Hclose"; first done.
       iMod ("He" with "[$]") as "[$ H]".
-      iModIntro. iIntros (e₂ σ₂ Hstep).
-      iMod ("H" with "[//]") as "H". iIntros "!> !>".
+      iModIntro. iIntros (e₂ σ₂ Hstep) "Hcred".
+      iMod ("H" with "[//] Hcred") as "H". iIntros "!> !>".
       iMod "H". iModIntro.
       iApply (step_fupdN_wand with "[H]"); first by iApply "H".
       iIntros ">($ & H)". iMod "Hclose" as "_". iModIntro.
@@ -234,8 +234,8 @@ Section reasoning_rules.
     - by iDestruct "H" as ">>> $".
     - by inversion H.
     - iIntros (σ1 ns k κs nt) "Hσ". iMod "H". iMod ("H" $! σ1 with "Hσ") as "[$ H]".
-      iModIntro. iIntros (e2 σ2 Hstep).
-      iApply (step_fupdN_wand with "[H]"); first by iApply "H".
+      iModIntro. iIntros (e2 σ2 Hstep) "Hcred".
+      iApply (step_fupdN_wand with "[H Hcred]"); first by iApply "H".
       iIntros ">(Hσ & H)".
       rewrite !ewp_unfold /ewp_pre.
         destruct (to_val e2) as [ v2     |] eqn:He2;
@@ -270,10 +270,17 @@ Section reasoning_rules.
       [iPureIntro; by apply (pure_prim_step_imp_reducible _ e')|].
       iIntros (e₂ σ₂ Hstep'). destruct k; [|done].
       destruct (pure_prim_step_det _ _ Hstep _ _ _ Hstep') as [-> ->].
-      simpl. iIntros "!> !>".
+      simpl. iIntros "Hcred !> !>". 
       iMod (state_interp_mono with "Hs") as "Hs". iModIntro.
+      iDestruct "Hcred" as "Hcred".
+      iPoseProof (lc_weaken (S (num_laters_per_step ns))) as "H"; 
+        first reflexivity.
+      iDestruct ("H" with "Hcred") as "Hcred". iClear "H".
       induction num_laters_per_step as [|k IH]; simpl;
-      [by iFrame|iIntros "!>!>!>"; by apply IH].
+      [by iFrame|iIntros "!>!>!>"].
+      iPoseProof (@lc_weaken _ _ (S (S k)) (S k)) as "H"; first lia.
+      iDestruct ("H" with "Hcred") as "Hcred". iClear "H".
+      apply IH.
   Qed.
 
   Lemma ewp_pure_step E e e' Ψ1 Ψ2 Φ :
@@ -353,10 +360,10 @@ Section reasoning_rules.
       iIntros "Hewp" (σ₁ ns k' ks nt) "Hs".
       iMod ("Hewp" $! σ₁ with "Hs") as "[% Hewp]". iModIntro.
       iSplitR; [iPureIntro; by apply reducible_fill|].
-      iIntros (e₂ σ₂) "%".
+      iIntros (e₂ σ₂) "% Hcred".
       destruct k'; [|done]. rename H1 into Hstep. simpl in Hstep.
       destruct (Ectx_prim_step_inv k _ _ _ _ He He' Hstep) as [e' [Hstep' ->]].
-      iMod ("Hewp" $! e' σ₂ Hstep') as "Hewp". iIntros "!> !>".
+      iMod ("Hewp" $! e' σ₂ Hstep' with "Hcred") as "Hewp". iIntros "!> !>".
       iMod "Hewp". iModIntro.
       iApply (step_fupdN_wand with "[Hewp]"); first by iApply "Hewp".
       iIntros "H". iMod "H" as "[$ Hewp]". iModIntro.
@@ -389,10 +396,10 @@ Section reasoning_rules.
       iIntros "Hewp"  (σ₁ ns k' ks nt) "Hs".
       iMod ("Hewp" $! σ₁ with "Hs") as "[% Hewp]". iModIntro.
       iSplitR; [iPureIntro; by apply reducible_fill|].
-      iIntros (e₂ σ₂) "%".
+      iIntros (e₂ σ₂) "% Hcred".
       destruct k';[|done]; rename H0 into Hstep, H into Hred.
       destruct (Ectx_prim_step_inv k _ _ _ _ He He' Hstep) as [e' [Hstep' ->]].
-      iMod ("Hewp" $! e' σ₂ Hstep') as "Hewp". iIntros "!> !>".
+      iMod ("Hewp" $! e' σ₂ Hstep' with "Hcred") as "Hewp". iIntros "!> !>".
       iMod "Hewp". iModIntro.
       iApply (step_fupdN_wand with "[Hewp]"); first by iApply "Hewp".
       iIntros "H". iMod "H" as "[$ Hewp]". iModIntro.
diff --git a/theories/program_logic/deep_handler_reasoning.v b/theories/program_logic/deep_handler_reasoning.v
index 56d7c0f..2cd2a7e 100644
--- a/theories/program_logic/deep_handler_reasoning.v
+++ b/theories/program_logic/deep_handler_reasoning.v
@@ -3,9 +3,9 @@
 (* This file introduces reasoning rules for deep handlers. *)
 
 From iris.proofmode Require Import base tactics classes.
-From program_logic Require Import protocols weakest_precondition
-                                  basic_reasoning_rules state_reasoning
-                                  shallow_handler_reasoning tactics.
+From hazel.program_logic Require Import protocols weakest_precondition
+                                        basic_reasoning_rules state_reasoning
+                                        shallow_handler_reasoning tactics.
 
 (* ========================================================================== *)
 (** * Implementation. *)
@@ -159,13 +159,13 @@ Proof.
   iApply (ewp_try_with with "[He] [Hhandler]");[|iSplit; [|iSplit]].
   - ewp_pure_steps. by iApply "He".
   - iIntros (y) "Hy". ewp_pure_steps. by iApply "Hhandler".
-  - iIntros (v k) "Hk". ewp_pure_steps.
+  - iIntros (v k) "Heq Hk". ewp_pure_steps.
     iDestruct "Hhandler" as "(_&Hh&_)". iApply "Hh".
     iApply (@monotonic_prot _ (upcl OS Ψ1) with "[] Hk").
     iIntros (w) "Hk". iIntros (Ψ1'' Ψ2'' Φ'') "Hdeep".
     ewp_pure_steps. iApply ("IH" with "[Hk] Hdeep").
     by ewp_pure_steps.
-  - iIntros (v k) "Hk". ewp_pure_steps.
+  - iIntros (v k) "Heq Hk". ewp_pure_steps.
     iDestruct "Hhandler" as "(_&_&Hh)". iApply "Hh".
     iApply (@pers_monotonic_prot _ (upcl MS Ψ2) with "[] Hk").
     iIntros "!#" (w) "Hk". iIntros (Ψ1'' Ψ2'' Φ'') "Hdeep".
diff --git a/theories/program_logic/protocols.v b/theories/program_logic/protocols.v
index 09ad69b..47ac8b6 100644
--- a/theories/program_logic/protocols.v
+++ b/theories/program_logic/protocols.v
@@ -9,7 +9,7 @@
 
 From iris.proofmode Require Import tactics.
 From iris.base_logic Require Export lib.iprop.
-From language Require Import eff_lang.
+From hazel.language Require Import eff_lang.
 
 Set Default Proof Using "Type".
 
diff --git a/theories/program_logic/reasoning_rules.v b/theories/program_logic/reasoning_rules.v
index 670dca0..3c50cf0 100644
--- a/theories/program_logic/reasoning_rules.v
+++ b/theories/program_logic/reasoning_rules.v
@@ -1,6 +1,6 @@
 (* reasoning_rules.v *)
 
-From program_logic Require Export protocols weakest_precondition
-                                  basic_reasoning_rules state_reasoning
-                                  shallow_handler_reasoning tactics
-                                  deep_handler_reasoning.
+From hazel.program_logic Require Export protocols weakest_precondition
+                                        basic_reasoning_rules state_reasoning
+                                        shallow_handler_reasoning tactics
+                                        deep_handler_reasoning.
diff --git a/theories/program_logic/shallow_handler_reasoning.v b/theories/program_logic/shallow_handler_reasoning.v
index 226541d..9513828 100644
--- a/theories/program_logic/shallow_handler_reasoning.v
+++ b/theories/program_logic/shallow_handler_reasoning.v
@@ -3,9 +3,9 @@
 (* This file introduces reasoning rules for shallow effect handlers. *)
 
 From iris.proofmode Require Import base tactics classes.
-From program_logic Require Import protocols weakest_precondition
-                                  basic_reasoning_rules
-                                  state_reasoning.
+From hazel.program_logic Require Import protocols weakest_precondition
+                                        basic_reasoning_rules
+                                        state_reasoning.
 
 
 (* ========================================================================== *)
@@ -30,11 +30,13 @@ Definition shallow_handler `{!heapGS Σ}
 
   (* Correctness of the effect branch -- one-shot case. *)
   (∀ (v k : val),
+     (∃ N l, k ≡ ContV N l) -∗
      iEff_car (upcl OS Ψ1) v (λ w, EWP k w @ E <| Ψ1 |> {| Ψ2 |} {{ Φ }}) -∗
        EWP h v k @ E <| Ψ1' |> {| Ψ2' |} {{ Φ' }}) ∧
 
   (* Correctness of the effect branch -- multi-shot case. *)
   (∀ (v k : val),
+     (∃ N, k ≡ KontV N) -∗
      iEff_car (upcl MS Ψ2) v (λ w, EWP k w @ E <| Ψ1 |> {| Ψ2 |} {{ Φ }}) -∗
        EWP h v k @ E <| Ψ1' |> {| Ψ2' |} {{ Φ' }}).
 
@@ -49,8 +51,10 @@ Global Instance shallow_handler_ne `{!heapGS Σ} E n :
   (shallow_handler (Σ:=Σ) E).
 Proof.
   intros ??? ??? ??? ??-> ??-> ??? ??? ???. rewrite /shallow_handler.
-  by repeat (apply iEff_car_ne || solve_proper || f_equiv).
+  f_equiv; first by solve_proper.
+  f_equiv; do 7 f_equiv; try (apply iEff_car_ne; solve_proper); try done; intros ?; by f_equiv.
 Qed.
+
 Global Instance shallow_handler_proper `{!heapGS Σ} E :
   Proper ((≡) ==> (≡) ==> (≡) ==> (≡) ==> (≡) ==> (≡) ==> (≡) ==> (≡) ==> (≡))
   (shallow_handler (Σ:=Σ) E).
@@ -73,13 +77,13 @@ Lemma shallow_handler_mono `{!heapGS Σ}
 Proof.
   iIntros "Hhandler #HΨ1 #HΨ2". iSplit; [|iSplit].
   - iIntros (y) "Hy". by iApply "Hhandler".
-  - iIntros (v k) "HΨ1''". iDestruct "Hhandler" as "(_&Hh&_)".
-    iApply "Hh". iApply (iEff_le_upcl with "HΨ1").
+  - iIntros (v k) "Heq HΨ1''". iDestruct "Hhandler" as "(_&Hh&_)".
+    iApply ("Hh" with "Heq"). iApply (iEff_le_upcl with "HΨ1").
     iApply (monotonic_prot with "[] HΨ1''").
     iIntros (w) "Hkw".
     by iApply (ewp_pers_smono with "Hkw"); auto.
-  - iIntros (v k) "HΨ2''". iDestruct "Hhandler" as "(_&_&Hh)".
-    iApply "Hh". iApply (iEff_le_upcl with "HΨ2").
+  - iIntros (v k) "Heq HΨ2''". iDestruct "Hhandler" as "(_&_&Hh)".
+    iApply ("Hh" with "Heq"). iApply (iEff_le_upcl with "HΨ2").
     iApply (pers_monotonic_prot with "[] HΨ2''").
     iIntros "!#" (w) "Hkw".
     by iApply (ewp_pers_smono with "Hkw"); auto.
@@ -97,11 +101,11 @@ Proof.
   - iIntros (y) "Hy". iDestruct "Hhandler" as "[Hr _]".
     iSpecialize ("Hr" with "Hy").
     by iApply (ewp_pers_smono with "Hr"); auto.
-  - iIntros (v k) "HΨ1". iDestruct "Hhandler" as "(_&Hh&_)".
-    iSpecialize ("Hh" with "HΨ1").
+  - iIntros (v k) "Heq HΨ1". iDestruct "Hhandler" as "(_&Hh&_)".
+    iSpecialize ("Hh" with "Heq HΨ1").
     by iApply (ewp_pers_smono with "Hh"); auto.
-  - iIntros (v k) "HΨ2". iDestruct "Hhandler" as "(_&_&Hh)".
-    iSpecialize ("Hh" with "HΨ2").
+  - iIntros (v k) "Heq HΨ2". iDestruct "Hhandler" as "(_&_&Hh)".
+    iSpecialize ("Hh" with "Heq HΨ2").
     by iApply (ewp_pers_smono with "Hh"); auto.
 Qed.
 
@@ -124,11 +128,11 @@ Proof.
   iIntros (σ ????) "Hσ".
   iDestruct (gen_heap_valid with "Hσ Hl") as "%".
   rename H into heap_valid.
-  iMod (gen_heap_update _ _ _ #true with "Hσ Hl") as "[Hσ Hl]".
+  iMod (gen_heap_update _ _ _ (Some #true) with "Hσ Hl") as "[Hσ Hl]".
   iMod (fupd_mask_subseteq ∅) as "Hclose". by apply empty_subseteq.
   iModIntro. iSplitR.
   - iPureIntro. rewrite /reducible //=.
-    exists [], (fill k w), (heap_upd <[l:=#true]> σ), []. simpl.
+    exists [], (fill k w), (heap_upd <[l:=Some #true]> σ), []. simpl.
     apply (Ectx_prim_step _ _ _ _ [] (ContV k l w) (fill k w)); try done.
     apply ContS; by eauto.
   - iIntros (e₂ σ₂ Hstep).
@@ -165,25 +169,27 @@ Proof.
       iMod (fupd_mask_subseteq ∅) as "Hclose". by apply empty_subseteq.
       iModIntro. iSplitR.
       * iPureIntro. rewrite /reducible //=.
-        set (l := fresh_locs (dom (gset loc) σ.(heap))).
-        exists [], (h v (ContV k l)), (heap_upd <[l:=#false]> σ), []. simpl.
+        set (l := Loc.fresh (dom σ.(heap))).
+        exists [], (h v (ContV k l)), (heap_upd <[l:=Some #false]> σ), []. simpl.
         apply (Ectx_prim_step _ _ _ _ []
               (TryWith (Eff OS v k) h r) (h v (ContV k l))); try done.
         by apply try_with_fresh.
       * iIntros (e₂ σ₂ Hstep). destruct κ; [|done]. simpl in Hstep.
         specialize (prim_step_inv_TryWithOSEff _ _ _ _ _ _ _ Hstep)
           as [l [Hlkp [-> ->]]].
-        iMod (gen_heap_alloc _ l #false with "Hσ") as "($ & Hl & Hm)". { done. }
-        iSpecialize ("Hh" $! v (ContV k l) with "[Heff Hl]").
+        iMod (gen_heap_alloc _ l (Some #false) with "Hσ") as "($ & Hl & Hm)". { done. }
+        iSpecialize ("Hh" $! v (ContV k l) with "[] [Heff Hl]").
+        { by iExists k, l. }
         { iDestruct "Heff" as "[%Q [HΨ1 Hk]]". iExists Q. iFrame.
           iIntros (w) "HQ". iApply (ewp_cont with "[HQ Hk] Hl").
           by iApply "Hk".
         }
-        iIntros "!> !> !>". by iMod "Hclose".
+        iIntros "Hcred !> !> !>". by iMod "Hclose".
     (* Multi-shot. *)
     + rewrite -ewp_eff_ms_eq.
       iApply ewp_pure_step. { by apply pure_prim_step_TryWithMSEff. }
-      iApply "Hh". iApply (pers_monotonic_prot with "[] Heff").
+      iApply ("Hh" with "[]"); first by iExists k. 
+      iApply (pers_monotonic_prot with "[] Heff").
       iIntros "!#" (w) "Hk".
       iApply ewp_pure_step'. { by apply pure_prim_step_Kont. }
       done.
@@ -202,7 +208,7 @@ Proof.
       inversion Hstep. simplify_eq.
       exists [], (TryWith (fill k e2') h r), σ₄, [].
       by apply (Ectx_prim_step _ _ _ _ ((TryWithCtx h r) :: k) e1' e2').
-    + iModIntro. iIntros (e₄ σ₄) "%".
+    + iModIntro. iIntros (e₄ σ₄) "% Hcred".
       destruct k'; [|done]. rename H0 into Hstep. simpl in Hstep.
       assert (Hstep' : ∃ e₅, prim_step e σ₁ e₅ σ₄ ∧ e₄ = TryWith e₅ h r).
       { inversion Hstep. destruct k as [|f k].
@@ -212,7 +218,7 @@ Proof.
           by apply (Ectx_prim_step _ _ _ _ k e1' e2').
       }
       destruct Hstep' as [e₅ [Hstep' ->]].
-      iDestruct ("He" $! e₅ σ₄ Hstep') as "> He".
+      iDestruct ("He" $! e₅ σ₄ Hstep' with "Hcred") as "> He".
       iIntros "!> !>". iMod "He". iModIntro.
       iMod "He" as "[$ He]". iModIntro.
       by iApply ("IH" with "He Hhandler").
diff --git a/theories/program_logic/state_reasoning.v b/theories/program_logic/state_reasoning.v
index ddefd96..a729a37 100644
--- a/theories/program_logic/state_reasoning.v
+++ b/theories/program_logic/state_reasoning.v
@@ -10,8 +10,8 @@ From iris.bi.lib Require Import fractional.
 From iris.base_logic.lib Require Export gen_heap proph_map gen_inv_heap.
 From iris.program_logic Require Export weakestpre total_weakestpre.
 From iris.program_logic Require Import ectx_lifting total_ectx_lifting.
-From program_logic Require Import weakest_precondition basic_reasoning_rules.
-From language Require Export eff_lang.
+From hazel.program_logic Require Import weakest_precondition basic_reasoning_rules.
+From hazel.language Require Export eff_lang.
 
 Set Default Proof Using "Type".
 
@@ -42,14 +42,14 @@ Set Default Proof Using "Type".
    on the global list of cameras [Σ]. *)
 Class heapGpreS Σ := {
   heap_GpreS_iris :> invGpreS Σ;
-  heap_GpreS_heap :> gen_heapGpreS loc val Σ;
-  heap_GpreS_inv_heap :> inv_heapGpreS loc val Σ;
+  heap_GpreS_heap :> gen_heapGpreS loc (option val) Σ;
+  heap_GpreS_inv_heap :> inv_heapGpreS loc (option val) Σ;
 }.
 
 (* We provide an explicit instance of such a list [Σ]
    to make sure that we do not perform vacuous reasoning. *)
 Definition heapΣ : gFunctors :=
-  #[invΣ; gen_heapΣ loc val; inv_heapΣ loc val].
+  #[invΣ; gen_heapΣ loc (option val); inv_heapΣ loc (option val)].
 
 Instance subG_heapPreG {Σ} : subG heapΣ Σ → heapGpreS Σ.
 Proof. solve_inG. Qed.
@@ -59,8 +59,8 @@ Proof. solve_inG. Qed.
    and other ghost cells related to invariants. *)
 Class heapGS Σ := HeapGS {
   heapG_invG : invGS Σ;
-  heapG_gen_heapG :> gen_heapGS loc val Σ;
-  heapG_inv_heapG :> inv_heapGS loc val Σ;
+  #[global] heapG_gen_heapG :> gen_heapGS loc (option val) Σ;
+  #[global] heapG_inv_heapG :> inv_heapGS loc (option val) Σ;
 }.
 
 
@@ -81,13 +81,13 @@ Global Instance heapG_irisG `{!heapGS Σ} : irisGS eff_lang Σ := {
 
 (* Derived notation for points-to predicates. *)
 
-Notation "l ↦{ dq } v" := (mapsto (L:=loc) (V:=val) l dq (v%V))
+Notation "l ↦{ dq } v" := (mapsto (L:=loc) (V:=option val) l dq (Some v%V))
   (at level 20, format "l  ↦{ dq }  v") : bi_scope.
-Notation "l ↦□ v" := (mapsto (L:=loc) (V:=val) l DfracDiscarded (v%V))
+Notation "l ↦□ v" := (mapsto (L:=loc) (V:=option val) l DfracDiscarded (Some v%V))
   (at level 20, format "l  ↦□  v") : bi_scope.
-Notation "l ↦{# q } v" := (mapsto (L:=loc) (V:=val) l (DfracOwn q) (v%V))
+Notation "l ↦{# q } v" := (mapsto (L:=loc) (V:=option val) l (DfracOwn q) (Some v%V))
   (at level 20, format "l  ↦{# q }  v") : bi_scope.
-Notation "l ↦ v" := (mapsto (L:=loc) (V:=val) l (DfracOwn 1) (v%V))
+Notation "l ↦ v" := (mapsto (L:=loc) (V:=option val) l (DfracOwn 1) (Some v%V))
   (at level 20, format "l  ↦  v") : bi_scope.
 
 
@@ -118,8 +118,8 @@ Section reasoning_rules.
     { by apply empty_subseteq. }
     iModIntro. iSplitR.
     - iPureIntro. rewrite /reducible //=.
-      set (l := fresh_locs (dom (gset loc) σ.(heap))).
-      exists [], #l, (heap_upd <[l:=v]> σ), []. simpl.
+      set (l := Loc.fresh (dom σ.(heap))).
+      exists [], #l, (heap_upd <[l:=Some v]> σ), []. simpl.
       apply (Ectx_prim_step _ _ _ _ [] (ref v)%E (#l)); try done.
       by apply alloc_fresh.
     - iIntros (e₂ σ₂ Hstep).
@@ -127,9 +127,9 @@ Section reasoning_rules.
       destruct Hstep; destruct k  as [|f k];
       [| destruct f; try naive_solver ].
       + simpl in H, H0. simplify_eq. inversion H1.
-        iMod (gen_heap_alloc _ l v with "Hσ") as "($ & Hl & Hm)". { done. }
-        iApply ewp_value.
-        iIntros "!> !> !>". iMod "Hclose". by iMod ("HΦ" with "Hl").
+        iMod (gen_heap_alloc _ l (Some v) with "Hσ") as "($ & Hl & Hm)". { done. }
+        iIntros "Hcred !>!>!>". iApply ewp_value.
+        iMod "Hclose". by iMod ("HΦ" with "Hl").
       + destruct (fill_val' k e1' v) as [-> ->]. naive_solver. by inversion H1.
   Qed.
 
@@ -145,7 +145,7 @@ Section reasoning_rules.
     iIntros "Hl HΦ".
     rewrite ewp_unfold /ewp_pre //=.
     iIntros (σ ????) "Hσ".
-    iAssert (▷ (l ↦{q} v ∗ gen_heap_interp (heap σ) ∗ ⌜ heap σ !! l = Some v ⌝))%I
+    iAssert (▷ (l ↦{q} v ∗ gen_heap_interp (heap σ) ∗ ⌜ heap σ !! l = Some (Some v) ⌝))%I
       with "[Hl Hσ]" as "(Hl & Hσ & >%heap_valid)".
     { iNext. iDestruct (gen_heap_valid with "Hσ Hl") as %H. by iFrame. }
     iMod (fupd_mask_subseteq ∅) as "Hclose". by apply empty_subseteq.
@@ -158,8 +158,8 @@ Section reasoning_rules.
       destruct κ; [|done]. simpl in Hstep.
       destruct Hstep; destruct k  as [|f k]; [| destruct f; try naive_solver ].
       + simpl in H, H0. simplify_eq. inversion H1. simplify_eq. iFrame.
-        iApply ewp_value. simpl.
-        iIntros "!> !> !>". iMod "Hclose". by iMod ("HΦ" with "Hl").
+        iIntros "Hcred !>!>!>". iApply ewp_value. simpl.
+        iMod "Hclose". by iMod ("HΦ" with "Hl").
       + destruct (fill_val' k e1' #l) as [-> ->]. naive_solver. by inversion H1.
   Qed.
 
@@ -175,17 +175,17 @@ Section reasoning_rules.
     iIntros "Hl HΦ".
     rewrite ewp_unfold /ewp_pre //=.
     iIntros (σ ????) "Hσ".
-    iAssert (▷ (l ↦ v ∗ gen_heap_interp (heap σ) ∗ ⌜ heap σ !! l = Some v ⌝))%I
+    iAssert (▷ (l ↦ v ∗ gen_heap_interp (heap σ) ∗ ⌜ heap σ !! l = Some (Some v) ⌝))%I
       with "[Hl Hσ]" as "(Hl & Hσ & >%Hvalid)".
     { iNext. iDestruct (gen_heap_valid with "Hσ Hl") as %H. by iFrame. }
     iApply fupd_mask_intro. by apply empty_subseteq. iIntros "Hclose".
     iSplitR.
     - iPureIntro. rewrite /reducible //=.
-      exists [], (#()), (heap_upd <[ l := w ]> σ), []. simpl.
+      exists [], (#()), (heap_upd <[ l := Some w ]> σ), []. simpl.
       apply (Ectx_prim_step _ _ _ _ [] (#l <- w)%E #()); try done.
-      apply StoreS. by eauto.
-    - iIntros (e₂ σ₂ Hstep) "!>!>".
-      iMod (gen_heap_update  _ _ _ w with "Hσ Hl") as "[Hσ Hl]".
+      eapply StoreS . by eauto.
+    - iIntros (e₂ σ₂ Hstep) "Hcred !>!>".
+      iMod (gen_heap_update  _ _ _ (Some w) with "Hσ Hl") as "[Hσ Hl]".
       destruct κ; [|done]. simpl in Hstep.
       destruct Hstep; destruct k  as [|f k]; [| destruct f; try naive_solver ].
       + simpl in H, H0. simplify_eq. inversion H1. simplify_eq. iFrame.
@@ -197,4 +197,69 @@ Section reasoning_rules.
       + destruct (fill_val' k e1' w)  as [-> ->]. naive_solver. by inversion H1.
   Qed.
 
+  (* ------------------------------------------------------------------------ *)
+  (** Replace. *)
+
+  Lemma ewp_replace E Ψ1 Ψ2 Φ l v w :
+    ▷ l ↦ v -∗
+      ▷ (l ↦ w ={E}=∗ Φ v) -∗
+        EWP (#l <!- w)%E @ E <| Ψ1 |> {| Ψ2 |} {{ Φ }}.
+  Proof.
+    iIntros "Hl HΦ".
+    rewrite ewp_unfold /ewp_pre //=.
+    iIntros (σ ????) "Hσ".
+    iAssert (▷ (l ↦ v ∗ gen_heap_interp (heap σ) ∗ ⌜ heap σ !! l = Some (Some v) ⌝))%I
+      with "[Hl Hσ]" as "(Hl & Hσ & >%Hvalid)".
+    { iNext. iDestruct (gen_heap_valid with "Hσ Hl") as %H. by iFrame. }
+    iApply fupd_mask_intro. by apply empty_subseteq. iIntros "Hclose".
+    iSplitR.
+    - iPureIntro. rewrite /reducible //=.
+      exists [], v, (heap_upd <[ l := Some w ]> σ), []. simpl.
+      apply (Ectx_prim_step _ _ _ _ [] (#l <!- w)%E v); try done.
+      eapply ReplaceS. by eauto.
+    - iIntros (e₂ σ₂ Hstep) "Hcred !>!>".
+      iMod (gen_heap_update  _ _ _ (Some w) with "Hσ Hl") as "[Hσ Hl]".
+      destruct κ; [|done]. simpl in Hstep.
+      destruct Hstep; destruct k  as [|f k]; [| destruct f; try naive_solver ].
+      + simpl in H, H0. simplify_eq. inversion H1. simplify_eq. iFrame.
+        iMod "Hclose". iMod ("HΦ" with "Hl").
+        iApply fupd_mask_intro. by apply empty_subseteq. iIntros "Hclose'".
+        iMod "Hclose'". iModIntro.
+        by iApply ewp_value.
+      + destruct (fill_val' k e1' #l) as [-> ->]. naive_solver. by inversion H1.
+      + destruct (fill_val' k e1' w)  as [-> ->]. naive_solver. by inversion H1.
+  Qed.
+
+  (* ------------------------------------------------------------------------ *)
+  (** Free. *)
+
+  Lemma ewp_free E Ψ1 Ψ2 Φ l v :
+    ▷ l ↦ v -∗
+    ▷ (|={E}=> Φ v) -∗
+      EWP Free #l @ E <| Ψ1 |> {| Ψ2 |} {{ Φ }}.
+  Proof.
+    iIntros "Hl HΦ".
+    rewrite ewp_unfold /ewp_pre //=.
+    iIntros (σ ????) "Hσ".
+    iAssert (▷ (l ↦ v ∗ gen_heap_interp (heap σ) ∗ ⌜ heap σ !! l = Some (Some v) ⌝))%I
+      with "[Hl Hσ]" as "(Hl & Hσ & >%Hvalid)".
+    { iNext. iDestruct (gen_heap_valid with "Hσ Hl") as %H. by iFrame. }
+    iApply fupd_mask_intro. by apply empty_subseteq. iIntros "Hclose".
+    iSplitR.
+    - iPureIntro. rewrite /reducible //=.
+      exists [], v, (heap_upd <[ l := None ]> σ), []. simpl.
+      apply (Ectx_prim_step _ _ _ _ [] (Free #l)%E v); try done.
+      eapply FreeS. by eauto.
+    - iIntros (e₂ σ₂ Hstep) "Hcred !>!>".
+      iMod (gen_heap_update  _ _ _ None with "Hσ Hl") as "[Hσ Hl]".
+      destruct κ; [|done]. simpl in Hstep.
+      destruct Hstep; destruct k  as [|f k]; [| destruct f; try naive_solver ].
+      + simpl in H, H0. simplify_eq. inversion H1. simplify_eq. iFrame.
+        iMod "Hclose". iMod "HΦ".
+        iApply fupd_mask_intro. by apply empty_subseteq. iIntros "Hclose'".
+        iMod "Hclose'". iModIntro.
+        by iApply ewp_value.
+      + destruct (fill_val' k e1' #l) as [-> ->]. naive_solver. by inversion H1.
+  Qed.
+
 End reasoning_rules.
diff --git a/theories/program_logic/tactics.v b/theories/program_logic/tactics.v
index 0058172..09df916 100644
--- a/theories/program_logic/tactics.v
+++ b/theories/program_logic/tactics.v
@@ -12,8 +12,8 @@
 *)
 
 From iris.proofmode Require Import base tactics classes.
-From language Require Import eff_lang.
-From program_logic Require Export weakest_precondition basic_reasoning_rules.
+From hazel.language Require Import eff_lang.
+From hazel.program_logic Require Export weakest_precondition basic_reasoning_rules.
 
 (* ========================================================================== *)
 (** Tactics. *)
@@ -40,9 +40,12 @@ Ltac reshape_expr e tac :=
     | InjR ?e               => add_item InjRCtx k e
     | Case ?e0 ?e1 ?e2      => add_item (CaseCtx e1 e2) k e0
     | Alloc ?e              => add_item AllocCtx k e
+    | Free ?e               => add_item FreeCtx k e
     | Load ?e               => add_item LoadCtx k e
     | Store ?e (Val ?v)     => add_item (StoreLCtx v) k e
     | Store ?e1 ?e2         => add_item (StoreRCtx e1) k e2
+    | Replace ?e (Val ?v)   => add_item (ReplaceLCtx v) k e
+    | Replace ?e1 ?e2       => add_item (ReplaceRCtx e1) k e2
 
     | Val _                 => tac k e
     | Eff _ _ _             => tac k e
diff --git a/theories/program_logic/weakest_precondition.v b/theories/program_logic/weakest_precondition.v
index 61ddf52..62b83a0 100644
--- a/theories/program_logic/weakest_precondition.v
+++ b/theories/program_logic/weakest_precondition.v
@@ -8,8 +8,8 @@
 
 From iris.proofmode Require Import base tactics classes.
 From iris.program_logic Require Import weakestpre.
-From language Require Export eff_lang.
-From program_logic Require Export protocols.
+From hazel.language Require Export eff_lang.
+From hazel.program_logic Require Export protocols.
 
 
 (* ========================================================================== *)
@@ -35,7 +35,8 @@ Definition ewp_pre `{!irisGS eff_lang Σ} :
           ∀ σ₁ ns κ κs nt,
             state_interp σ₁ ns (κ ++ κs) nt ={E,∅}=∗
               ⌜ reducible e₁ σ₁ ⌝ ∗ 
-              ∀ e₂ σ₂, ⌜ prim_step' e₁ σ₁ κ e₂ σ₂ [] ⌝
+              ∀ e₂ σ₂, ⌜ prim_step' e₁ σ₁ κ e₂ σ₂ [] ⌝ -∗
+                £ (S (num_laters_per_step ns))
                 ={∅}▷=∗^(S $ num_laters_per_step ns) |={∅,E}=>
                 state_interp σ₂ (S ns) κs nt ∗ ewp E e₂ Ψ₁ Ψ₂ Φ
       end
@@ -45,7 +46,7 @@ Local Instance ewp_pre_contractive `{!irisGS eff_lang Σ} : Contractive ewp_pre.
 Proof.
   rewrite /ewp_pre=> n ewp ewp' Hwp E e Ψ1 Ψ2 Φ.
   do 6 f_equiv; try by intros =>?; f_contractive; apply Hwp.
-  do 14 (f_contractive || f_equiv). 
+  do 15 (f_contractive || f_equiv). 
   induction num_laters_per_step as [|k IH]; simpl.
   - repeat (f_contractive || f_equiv); apply Hwp.
   - do 3 f_equiv. by apply IH.
@@ -80,7 +81,7 @@ Proof.
     apply IH; try lia; eapply dist_le; eauto with lia.
   - do 14 (f_contractive || f_equiv).
     induction num_laters_per_step as [|k IH']; simpl.
-    + do 2 (f_contractive || f_equiv).
+    + do 3 (f_contractive || f_equiv).
       apply IH; try lia; eapply dist_le; eauto with lia.
     + do 3 f_equiv. by apply IH'.
 Qed.
@@ -100,15 +101,15 @@ Notation "'EWP' e @ E {{ Φ } }" :=
   (ewp_def E e%E iEff_bottom iEff_bottom Φ)
   (at level 20, e, Φ at level 200,
    format "'[' 'EWP'  e  '/' '[          ' @  E  {{  Φ  } } ']' ']'") : bi_scope.
-Notation "'EWP' e @ E <| Ψ '|' '>'  {{ Φ } }" :=
+Notation "'EWP' e @ E <| Ψ '|' '>' {{ Φ } }" :=
   (ewp_def E e%E Ψ%ieff iEff_bottom Φ)
   (at level 20, e, Ψ, Φ at level 200,
    format "'[' 'EWP'  e  '/' '[          ' @  E  <|  Ψ  '|' '>'  {{  Φ  } } ']' ']'") : bi_scope.
-Notation "'EWP' e @ E .{| Ψ '|' '}'  {{ Φ } }" :=
+Notation "'EWP' e @ E .{| Ψ '|' '}' {{ Φ } }" :=
   (ewp_def E e%E iEff_bottom Ψ%ieff Φ)
   (at level 20, e, Ψ, Φ at level 200,
    format "'[' 'EWP'  e  '/' '[          ' @  E  .{|  Ψ  '|' '}'  {{  Φ  } } ']' ']'") : bi_scope.
-Notation "'EWP' e @ E <| Ψ1 '|' '>' {| Ψ2 '|' '}'  {{ Φ } }" :=
+Notation "'EWP' e @ E <| Ψ1 '|' '>' {| Ψ2 '|' '}' {{ Φ } }" :=
   (ewp_def E e%E Ψ1%ieff Ψ2%ieff Φ)
   (at level 20, e, Ψ1, Ψ2, Φ at level 200,
    format "'[' 'EWP'  e  '/' '[          ' @  E  <|  Ψ1  '|' '>'  {|  Ψ2  '|' '}'  {{  Φ  } } ']' ']'") : bi_scope.
@@ -118,51 +119,51 @@ Notation "'EWP' e @ E {{ v , Φ } }" :=
   (ewp_def E e%E iEff_bottom iEff_bottom (λ v, Φ)%I)
   (at level 20, e, Φ at level 200,
    format "'[' 'EWP'  e  '/' '[          ' @  E  {{  v ,  Φ  } } ']' ']'") : bi_scope.
-Notation "'EWP' e @ E <| Ψ '|' '>'  {{ v , Φ } }" :=
+Notation "'EWP' e @ E <| Ψ '|' '>' {{ v , Φ } }" :=
   (ewp_def E e%E Ψ%ieff iEff_bottom (λ v, Φ)%I)
   (at level 20, e, Ψ, Φ at level 200,
    format "'[' 'EWP'  e  '/' '[          ' @  E  <|  Ψ  '|' '>'  {{  v ,  Φ  } } ']' ']'") : bi_scope.
-Notation "'EWP' e @ E .{| Ψ '|' '}'  {{ v , Φ } }" :=
+Notation "'EWP' e @ E .{| Ψ '|' '}' {{ v , Φ } }" :=
   (ewp_def E e%E iEff_bottom Ψ%ieff (λ v, Φ)%I)
   (at level 20, e, Ψ, Φ at level 200,
    format "'[' 'EWP'  e  '/' '[          ' @  E  .{|  Ψ  '|' '}'  {{  v ,  Φ  } } ']' ']'") : bi_scope.
-Notation "'EWP' e @ E <| Ψ1 '|' '>' {| Ψ2 '|' '}'  {{ v , Φ } }" :=
+Notation "'EWP' e @ E <| Ψ1 '|' '>' {| Ψ2 '|' '}' {{ v , Φ } }" :=
   (ewp_def E e%E Ψ1%ieff Ψ2%ieff (λ v, Φ)%I)
   (at level 20, e, Ψ1, Ψ2, Φ at level 200,
    format "'[' 'EWP'  e  '/' '[          ' @  E  <|  Ψ1  '|' '>'  {|  Ψ2  '|' '}'  {{  v ,  Φ  } } ']' ']'") : bi_scope.
 
 (* Mask is implicitly specified by ⊤. *)
-Notation "'EWP' e  {{ v , Φ } }" :=
+Notation "'EWP' e {{ v , Φ } }" :=
   (ewp_def ⊤ e%E iEff_bottom iEff_bottom (λ v, Φ)%I)
   (at level 20, e, Φ at level 200,
    format "'[' 'EWP'  e  '/' '[          ' {{  v ,  Φ  } } ']' ']'") : bi_scope.
-Notation "'EWP' e  <| Ψ '|' '>'  {{ v , Φ } }" :=
+Notation "'EWP' e <| Ψ '|' '>' {{ v , Φ } }" :=
   (ewp_def ⊤ e%E Ψ%ieff iEff_bottom (λ v, Φ)%I)
   (at level 20, e, Ψ, Φ at level 200,
    format "'[' 'EWP'  e  '/' '[          ' <|  Ψ  '|' '>'  {{  v ,  Φ  } } ']' ']'") : bi_scope.
-Notation "'EWP' e .{| Ψ '|' '}'  {{ v , Φ } }" :=
+Notation "'EWP' e .{| Ψ '|' '}' {{ v , Φ } }" :=
   (ewp_def ⊤ e%E iEff_bottom Ψ%ieff (λ v, Φ)%I)
   (at level 20, e, Ψ, Φ at level 200,
    format "'[' 'EWP'  e  '/' '[          ' .{|  Ψ  '|' '}'  {{  v ,  Φ  } } ']' ']'") : bi_scope.
-Notation "'EWP' e <| Ψ1 '|' '>' {| Ψ2 '|' '}'  {{ v , Φ } }" :=
+Notation "'EWP' e <| Ψ1 '|' '>' {| Ψ2 '|' '}' {{ v , Φ } }" :=
   (ewp_def ⊤ e%E Ψ1%ieff Ψ2%ieff (λ v, Φ)%I)
   (at level 20, e, Ψ1, Ψ2, Φ at level 200,
    format "'[' 'EWP'  e  '/' '[          ' <|  Ψ1  '|' '>'  {|  Ψ2  '|' '}'  {{  v ,  Φ  } } ']' ']'") : bi_scope.
 
 (* No binder and no mask. *)
-Notation "'EWP' e  {{ Φ } }" :=
+Notation "'EWP' e {{ Φ } }" :=
   (ewp_def ⊤ e%E iEff_bottom iEff_bottom Φ%I)
   (at level 20, e, Φ at level 200,
    format "'[' 'EWP'  e  '/' '[          ' {{  Φ  } } ']' ']'") : bi_scope.
-Notation "'EWP' e  <| Ψ '|' '>'  {{ Φ } }" :=
+Notation "'EWP' e <| Ψ '|' '>' {{ Φ } }" :=
   (ewp_def ⊤ e%E Ψ%ieff iEff_bottom Φ%I)
   (at level 20, e, Ψ, Φ at level 200,
    format "'[' 'EWP'  e  '/' '[          ' <|  Ψ  '|' '>'  {{  Φ  } } ']' ']'") : bi_scope.
-Notation "'EWP' e .{| Ψ '|' '}'  {{ Φ } }" :=
+Notation "'EWP' e .{| Ψ '|' '}' {{ Φ } }" :=
   (ewp_def ⊤ e%E iEff_bottom Ψ%ieff Φ%I)
   (at level 20, e, Ψ, Φ at level 200,
    format "'[' 'EWP'  e  '/' '[          ' .{|  Ψ  '|' '}'  {{  Φ  } } ']' ']'") : bi_scope.
-Notation "'EWP' e <| Ψ1 '|' '>' {| Ψ2 '|' '}'  {{ Φ } }" :=
+Notation "'EWP' e <| Ψ1 '|' '>' {| Ψ2 '|' '}' {{ Φ } }" :=
   (ewp_def ⊤ e%E Ψ1%ieff Ψ2%ieff Φ%I)
   (at level 20, e, Ψ1, Ψ2, Φ at level 200,
    format "'[' 'EWP'  e  '/' '[          ' <|  Ψ1  '|' '>'  {|  Ψ2  '|' '}'  {{  Φ  } } ']' ']'") : bi_scope.
diff --git a/theories/program_logic_ext/named_effects.v b/theories/program_logic_ext/named_effects.v
deleted file mode 100644
index e69de29..0000000
